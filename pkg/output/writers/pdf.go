// Package writers provides output writers for various formats.
package writers

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"sync"
	"time"

	gofpdf "github.com/go-pdf/fpdf"
	"github.com/waftester/waftester/pkg/defaults"
	"github.com/waftester/waftester/pkg/output/dispatcher"
	"github.com/waftester/waftester/pkg/output/events"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// Compile-time interface check.
var _ dispatcher.Writer = (*PDFWriter)(nil)

// pdfSeverityColors maps severity levels to RGB color values.
var pdfSeverityColors = map[string][]int{
	"critical": {220, 38, 38}, // Red
	"high":     {234, 88, 12}, // Orange
	"medium":   {202, 138, 4}, // Yellow
	"low":      {22, 163, 74}, // Green
	"info":     {37, 99, 235}, // Blue
}

// pdfOutcomeColors maps outcomes to RGB color values.
var pdfOutcomeColors = map[events.Outcome][]int{
	events.OutcomeBypass:  {220, 38, 38}, // Red - bypass is bad
	events.OutcomeBlocked: {22, 163, 74}, // Green - blocked is good
	events.OutcomeError:   {202, 138, 4}, // Yellow
	events.OutcomeTimeout: {37, 99, 235}, // Blue
	events.OutcomePass:    {22, 163, 74}, // Green
}

// PDFConfig configures the PDF report writer.
type PDFConfig struct {
	// Title is the report title (default: "WAFtester Security Report")
	Title string

	// CompanyName is the company name for branding (optional)
	CompanyName string

	// CompanyLogo is the path to company logo (PNG/JPG) (optional)
	CompanyLogo string

	// Author is the report author (optional)
	Author string

	// IncludeEvidence includes payload and curl command in findings (default: true)
	IncludeEvidence bool

	// PageSize sets the page size: "A4" or "Letter" (default: "A4")
	PageSize string

	// Orientation sets page orientation: "P" (portrait) or "L" (landscape) (default: "P")
	Orientation string

	// Classification sets the document classification (CONFIDENTIAL, INTERNAL, PUBLIC)
	Classification string

	// IncludeTOC adds table of contents (default: true)
	IncludeTOC bool

	// WatermarkText adds a diagonal watermark to all pages (optional)
	WatermarkText string

	// FooterText customizes the footer text (default: "Generated by WAFtester")
	FooterText string
}

// PDFWriter writes events as a styled PDF report.
// It buffers all events in memory and renders the complete PDF document on Close.
// The writer is safe for concurrent use.
type PDFWriter struct {
	w       io.Writer
	mu      sync.Mutex
	config  PDFConfig
	results []*events.ResultEvent
	summary *events.SummaryEvent
}

// NewPDFWriter creates a new PDF report writer.
// The writer buffers all events and writes a complete PDF report on Close.
func NewPDFWriter(w io.Writer, config PDFConfig) *PDFWriter {
	if config.Title == "" {
		config.Title = "WAFtester Security Report"
	}
	if config.PageSize == "" {
		config.PageSize = "A4"
	}
	if config.Orientation == "" {
		config.Orientation = "P"
	}
	// Default to include evidence
	if !config.IncludeEvidence {
		config.IncludeEvidence = true
	}

	return &PDFWriter{
		w:       w,
		config:  config,
		results: make([]*events.ResultEvent, 0),
	}
}

// Write buffers an event for later PDF output.
func (pw *PDFWriter) Write(event events.Event) error {
	pw.mu.Lock()
	defer pw.mu.Unlock()

	switch e := event.(type) {
	case *events.ResultEvent:
		pw.results = append(pw.results, e)
	case *events.SummaryEvent:
		pw.summary = e
	}
	return nil
}

// Flush is a no-op for PDF writer.
// All events are written as a single PDF document on Close.
func (pw *PDFWriter) Flush() error {
	return nil
}

// Close renders and writes the complete PDF report.
func (pw *PDFWriter) Close() error {
	pw.mu.Lock()
	defer pw.mu.Unlock()

	pdf := pw.createPDF()
	pageW, pageH := pdf.GetPageSize()
	pw.setupHeaderFooter(pdf, pageW, pageH)

	pw.addCoverPage(pdf)
	if pw.config.IncludeTOC {
		pw.addTableOfContents(pdf)
	}
	pw.addExecutiveSummary(pdf)
	pw.addOWASPTable(pdf)
	pw.addFindingsSection(pdf)
	pw.addMethodologyAppendix(pdf)

	return pdf.Output(pw.w)
}

// SupportsEvent returns true for result and summary events.
func (pw *PDFWriter) SupportsEvent(eventType events.EventType) bool {
	switch eventType {
	case events.EventTypeResult, events.EventTypeSummary:
		return true
	default:
		return false
	}
}

// createPDF initializes a new PDF document with the configured settings.
func (pw *PDFWriter) createPDF() *gofpdf.Fpdf {
	pdf := gofpdf.New(pw.config.Orientation, "mm", pw.config.PageSize, "")

	// Set document info
	pdf.SetTitle(pw.config.Title, true)
	if pw.config.Author != "" {
		pdf.SetAuthor(pw.config.Author, true)
	}
	pdf.SetCreator("WAFtester", true)
	pdf.SetCreationDate(time.Now())

	// Set margins
	pdf.SetMargins(15, 15, 15)
	pdf.SetAutoPageBreak(true, 20)

	return pdf
}

// addCoverPage creates the professional cover page.
func (pw *PDFWriter) addCoverPage(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	// Get page dimensions
	pageW, pageH := pdf.GetPageSize()

	// Background color header strip
	pdf.SetFillColor(30, 41, 59) // Slate-800
	pdf.Rect(0, 0, pageW, 80, "F")

	// Company logo if provided
	if pw.config.CompanyLogo != "" {
		// Try to add the logo - if it fails, we just skip it
		pdf.ImageOptions(pw.config.CompanyLogo, pageW-60, 15, 45, 0, false,
			gofpdf.ImageOptions{ReadDpi: true}, 0, "")
	}

	// Title
	pdf.SetFont("Helvetica", "B", 28)
	pdf.SetTextColor(255, 255, 255)
	pdf.SetXY(15, 25)
	pdf.CellFormat(pageW-80, 15, pw.config.Title, "", 1, "L", false, 0, "")

	// Classification badge
	pdf.SetY(60)
	pdf.SetFont("Helvetica", "B", 10)
	pdf.SetFillColor(220, 38, 38) // Red for CONFIDENTIAL
	pdf.SetTextColor(255, 255, 255)
	classification := "CONFIDENTIAL"
	if pw.config.Classification != "" {
		classification = strings.ToUpper(pw.config.Classification)
	}
	if classification == "INTERNAL" {
		pdf.SetFillColor(202, 138, 4) // Yellow for INTERNAL
	} else if classification == "PUBLIC" {
		pdf.SetFillColor(22, 163, 74) // Green for PUBLIC
	}
	badgeW := pdf.GetStringWidth(classification) + 12
	pdf.SetX((pageW - badgeW) / 2)
	pdf.CellFormat(badgeW, 8, classification, "", 1, "C", true, 0, "")

	// Company name if provided
	if pw.config.CompanyName != "" {
		pdf.SetFont("Helvetica", "", 14)
		pdf.SetTextColor(200, 200, 200)
		pdf.SetXY(15, 45)
		pdf.CellFormat(pageW-30, 10, pw.config.CompanyName, "", 1, "L", false, 0, "")
	}

	// Target and date info box
	pdf.SetFont("Helvetica", "", 12)
	pdf.SetTextColor(60, 60, 60)

	targetURL := "Unknown"
	wafDetected := "Unknown"
	scanDate := time.Now().Format("2006-01-02 15:04 MST")

	if pw.summary != nil {
		targetURL = pw.summary.Target.URL
		if pw.summary.Target.WAFDetected != "" {
			wafDetected = pw.summary.Target.WAFDetected
		}
		if !pw.summary.Timing.StartedAt.IsZero() {
			scanDate = pw.summary.Timing.StartedAt.Format("2006-01-02 15:04 MST")
		}
	}

	// Info section
	pdf.SetY(100)
	pw.addInfoRow(pdf, "Target URL:", targetURL)
	pw.addInfoRow(pdf, "WAF Detected:", wafDetected)
	pw.addInfoRow(pdf, "Scan Date:", scanDate)
	if pw.config.Author != "" {
		pw.addInfoRow(pdf, "Report Author:", pw.config.Author)
	}

	// Grade box - centered
	if pw.summary != nil {
		grade := pw.summary.Effectiveness.Grade
		gradeColor := pw.getGradeColor(grade)

		pdf.SetY(pageH/2 - 30)
		pdf.SetFont("Helvetica", "B", 16)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(pageW-30, 10, "WAF Effectiveness Grade", "", 1, "C", false, 0, "")

		// Grade circle
		pdf.SetFillColor(gradeColor[0], gradeColor[1], gradeColor[2])
		pdf.Circle(pageW/2, pageH/2+10, 30, "F")

		pdf.SetFont("Helvetica", "B", 48)
		pdf.SetTextColor(255, 255, 255)
		pdf.SetXY(0, pageH/2-5)
		pdf.CellFormat(pageW, 30, grade, "", 1, "C", false, 0, "")

		// Block rate
		pdf.SetFont("Helvetica", "", 14)
		pdf.SetTextColor(60, 60, 60)
		pdf.SetY(pageH/2 + 45)
		blockRate := fmt.Sprintf("Block Rate: %.1f%%", pw.summary.Effectiveness.BlockRatePct)
		pdf.CellFormat(pageW-30, 10, blockRate, "", 1, "C", false, 0, "")
	}

	// Footer
	pdf.SetY(pageH - 30)
	pdf.SetFont("Helvetica", "I", 10)
	pdf.SetTextColor(128, 128, 128)
	pdf.CellFormat(pageW-30, 8, "Generated by WAFtester - Web Application Firewall Testing Tool", "", 0, "C", false, 0, "")
}

// addInfoRow adds a label-value row to the PDF.
func (pw *PDFWriter) addInfoRow(pdf *gofpdf.Fpdf, label, value string) {
	pdf.SetFont("Helvetica", "B", 11)
	pdf.SetTextColor(80, 80, 80)
	pdf.CellFormat(40, 8, label, "", 0, "L", false, 0, "")
	pdf.SetFont("Helvetica", "", 11)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 8, value, "", 1, "L", false, 0, "")
}

// getGradeColor returns RGB color for the effectiveness grade.
func (pw *PDFWriter) getGradeColor(grade string) []int {
	switch grade {
	case "A+", "A", "A-":
		return []int{22, 163, 74} // Green
	case "B+", "B", "B-":
		return []int{37, 99, 235} // Blue
	case "C+", "C", "C-":
		return []int{202, 138, 4} // Yellow
	case "D+", "D", "D-":
		return []int{234, 88, 12} // Orange
	default:
		return []int{220, 38, 38} // Red (F)
	}
}

// addExecutiveSummary creates the executive summary section.
func (pw *PDFWriter) addExecutiveSummary(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	// Section header
	pw.addSectionHeader(pdf, "Executive Summary")

	if pw.summary == nil {
		pdf.SetFont("Helvetica", "I", 11)
		pdf.SetTextColor(128, 128, 128)
		pdf.CellFormat(0, 8, "No summary data available", "", 1, "L", false, 0, "")
		return
	}

	// Summary statistics table
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Test Statistics", "", 1, "L", false, 0, "")

	// Statistics grid
	stats := []struct {
		label string
		value int
		color []int
	}{
		{"Total Tests", pw.summary.Totals.Tests, []int{60, 60, 60}},
		{"Blocked", pw.summary.Totals.Blocked, []int{22, 163, 74}},
		{"Bypasses", pw.summary.Totals.Bypasses, []int{220, 38, 38}},
		{"Errors", pw.summary.Totals.Errors, []int{202, 138, 4}},
		{"Timeouts", pw.summary.Totals.Timeouts, []int{37, 99, 235}},
	}

	pageW, _ := pdf.GetPageSize()
	cellW := (pageW - 30) / 5

	// Stat boxes
	startY := pdf.GetY() + 5
	for i, stat := range stats {
		x := 15 + float64(i)*cellW

		// Box background
		pdf.SetFillColor(245, 245, 245)
		pdf.Rect(x, startY, cellW-2, 25, "F")

		// Value
		pdf.SetFont("Helvetica", "B", 18)
		pdf.SetTextColor(stat.color[0], stat.color[1], stat.color[2])
		pdf.SetXY(x, startY+2)
		pdf.CellFormat(cellW-2, 12, fmt.Sprintf("%d", stat.value), "", 0, "C", false, 0, "")

		// Label
		pdf.SetFont("Helvetica", "", 9)
		pdf.SetTextColor(100, 100, 100)
		pdf.SetXY(x, startY+14)
		pdf.CellFormat(cellW-2, 8, stat.label, "", 0, "C", false, 0, "")
	}

	pdf.SetY(startY + 35)

	// Severity breakdown
	if len(pw.summary.Breakdown.BySeverity) > 0 {
		pdf.SetFont("Helvetica", "B", 12)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 10, "Findings by Severity", "", 1, "L", false, 0, "")

		// Count bypass findings by severity
		severityCounts := pw.countBypassesBySeverity()

		// Table header
		pdf.SetFont("Helvetica", "B", 10)
		pdf.SetFillColor(240, 240, 240)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(50, 8, "Severity", "1", 0, "C", true, 0, "")
		pdf.CellFormat(40, 8, "Bypasses", "1", 0, "C", true, 0, "")
		pdf.CellFormat(40, 8, "Total", "1", 0, "C", true, 0, "")
		pdf.CellFormat(40, 8, "Block Rate", "1", 1, "C", true, 0, "")

		// Table rows
		pdf.SetFont("Helvetica", "", 10)
		severityOrder := []string{"critical", "high", "medium", "low", "info"}
		for _, sev := range severityOrder {
			stats, exists := pw.summary.Breakdown.BySeverity[sev]
			if !exists {
				continue
			}

			color := pdfSeverityColors[sev]
			pdf.SetTextColor(color[0], color[1], color[2])
			pdf.CellFormat(50, 7, cases.Title(language.English).String(sev), "1", 0, "L", false, 0, "")

			bypassCount := severityCounts[sev]
			pdf.SetTextColor(60, 60, 60)
			pdf.CellFormat(40, 7, fmt.Sprintf("%d", bypassCount), "1", 0, "C", false, 0, "")
			pdf.CellFormat(40, 7, fmt.Sprintf("%d", stats.Total), "1", 0, "C", false, 0, "")
			pdf.CellFormat(40, 7, fmt.Sprintf("%.1f%%", stats.BlockRate), "1", 1, "C", false, 0, "")
		}

		// Add severity distribution bar chart
		pw.addSeverityBarChart(pdf, severityCounts)
	}

	// Add risk gauge visualization
	if pw.summary.Effectiveness.BlockRatePct >= 0 {
		pdf.Ln(10)
		pdf.SetFont("Helvetica", "B", 12)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 10, "WAF Protection Score", "", 1, "L", false, 0, "")
		pw.addRiskGauge(pdf, pw.summary.Effectiveness.BlockRatePct)
	}

	// Recommendation
	if pw.summary.Effectiveness.Recommendation != "" {
		pdf.Ln(10)
		pdf.SetFont("Helvetica", "B", 12)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 10, "Recommendation", "", 1, "L", false, 0, "")

		pdf.SetFont("Helvetica", "", 11)
		pdf.SetTextColor(80, 80, 80)
		pdf.MultiCell(0, 6, pw.summary.Effectiveness.Recommendation, "", "L", false)
	}
}

// countBypassesBySeverity counts bypass results by severity from buffered results.
func (pw *PDFWriter) countBypassesBySeverity() map[string]int {
	counts := make(map[string]int)
	for _, r := range pw.results {
		if r.Result.Outcome == events.OutcomeBypass {
			sev := string(r.Test.Severity)
			counts[sev]++
		}
	}
	return counts
}

// addSectionHeader adds a styled section header.
func (pw *PDFWriter) addSectionHeader(pdf *gofpdf.Fpdf, title string) {
	pdf.SetFont("Helvetica", "B", 18)
	pdf.SetTextColor(30, 41, 59) // Slate-800
	pdf.CellFormat(0, 12, title, "", 1, "L", false, 0, "")

	// Underline
	pdf.SetDrawColor(30, 41, 59)
	pdf.SetLineWidth(0.5)
	pageW, _ := pdf.GetPageSize()
	y := pdf.GetY()
	pdf.Line(15, y, pageW-15, y)
	pdf.Ln(8)
}

// OWASP Top 10 2021 reference data - uses defaults.OWASPTop10 and defaults.OWASPTop10Ordered.

// addOWASPTable creates the OWASP Top 10 mapping table.
func (pw *PDFWriter) addOWASPTable(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	pw.addSectionHeader(pdf, "OWASP Top 10 Coverage")

	// Build OWASP stats from results
	owaspStats := pw.buildOWASPStats()

	// Table header
	pdf.SetFont("Helvetica", "B", 10)
	pdf.SetFillColor(30, 41, 59) // Dark header
	pdf.SetTextColor(255, 255, 255)
	pdf.CellFormat(25, 8, "Code", "1", 0, "C", true, 0, "")
	pdf.CellFormat(70, 8, "Category", "1", 0, "L", true, 0, "")
	pdf.CellFormat(25, 8, "Tests", "1", 0, "C", true, 0, "")
	pdf.CellFormat(25, 8, "Bypasses", "1", 0, "C", true, 0, "")
	pdf.CellFormat(30, 8, "Status", "1", 1, "C", true, 0, "")

	// Table rows
	pdf.SetFont("Helvetica", "", 10)
	for _, code := range defaults.OWASPTop10Ordered {
		cat := defaults.OWASPTop10[code]
		stats := owaspStats[code]

		pdf.SetTextColor(60, 60, 60)
		pdf.SetFillColor(250, 250, 250)
		pdf.CellFormat(25, 7, code, "1", 0, "C", true, 0, "")
		pdf.CellFormat(70, 7, cat.Name, "1", 0, "L", true, 0, "")
		pdf.CellFormat(25, 7, fmt.Sprintf("%d", stats.Total), "1", 0, "C", true, 0, "")

		// Bypasses with color
		if stats.Bypasses > 0 {
			pdf.SetTextColor(220, 38, 38)
		}
		pdf.CellFormat(25, 7, fmt.Sprintf("%d", stats.Bypasses), "1", 0, "C", true, 0, "")
		pdf.SetTextColor(60, 60, 60)

		// Status badge
		status := "N/A"
		statusColor := []int{128, 128, 128}
		if stats.Total > 0 {
			if stats.Bypasses == 0 {
				status = "PASS"
				statusColor = []int{22, 163, 74}
			} else {
				status = "FAIL"
				statusColor = []int{220, 38, 38}
			}
		}
		pdf.SetTextColor(statusColor[0], statusColor[1], statusColor[2])
		pdf.SetFont("Helvetica", "B", 10)
		pdf.CellFormat(30, 7, status, "1", 1, "C", true, 0, "")
		pdf.SetFont("Helvetica", "", 10)
	}
}

// buildOWASPStats builds OWASP statistics from buffered results.
func (pw *PDFWriter) buildOWASPStats() map[string]*struct{ Total, Bypasses int } {
	stats := make(map[string]*struct{ Total, Bypasses int })

	// Initialize all OWASP categories using centralized data
	for _, code := range defaults.OWASPTop10Ordered {
		stats[code] = &struct{ Total, Bypasses int }{}
	}

	// Count from results
	for _, r := range pw.results {
		for _, owaspCode := range r.Test.OWASP {
			if s, ok := stats[owaspCode]; ok {
				s.Total++
				if r.Result.Outcome == events.OutcomeBypass {
					s.Bypasses++
				}
			}
		}
	}

	// Also include summary data if available
	if pw.summary != nil && pw.summary.Breakdown.ByOWASP != nil {
		for code, summaryStats := range pw.summary.Breakdown.ByOWASP {
			if s, ok := stats[code]; ok {
				// Use summary data if we have no results
				if s.Total == 0 {
					s.Total = summaryStats.Total
					s.Bypasses = summaryStats.Bypasses
				}
			}
		}
	}

	return stats
}

// addFindingsSection creates the detailed findings section.
func (pw *PDFWriter) addFindingsSection(pdf *gofpdf.Fpdf) {
	// Only include bypass findings
	bypasses := pw.getBypassResults()
	if len(bypasses) == 0 {
		pdf.AddPage()
		pw.addSectionHeader(pdf, "Detailed Findings")
		pdf.SetFont("Helvetica", "I", 11)
		pdf.SetTextColor(100, 100, 100)
		pdf.CellFormat(0, 8, "No bypass vulnerabilities detected.", "", 1, "L", false, 0, "")
		return
	}

	// Group by category
	byCategory := pw.groupByCategory(bypasses)

	// Get sorted category names
	categories := make([]string, 0, len(byCategory))
	for cat := range byCategory {
		categories = append(categories, cat)
	}
	sort.Strings(categories)

	for _, category := range categories {
		findings := byCategory[category]

		pdf.AddPage()
		pw.addSectionHeader(pdf, fmt.Sprintf("Findings: %s", strings.ToUpper(category)))

		for i, finding := range findings {
			if i > 0 {
				pdf.Ln(5)
			}

			pw.addFindingCard(pdf, finding, i+1)

			// Check if we need a new page
			if pdf.GetY() > 250 {
				pdf.AddPage()
			}
		}
	}
}

// getBypassResults filters for bypass-only results.
func (pw *PDFWriter) getBypassResults() []*events.ResultEvent {
	bypasses := make([]*events.ResultEvent, 0)
	for _, r := range pw.results {
		if r.Result.Outcome == events.OutcomeBypass {
			bypasses = append(bypasses, r)
		}
	}
	return bypasses
}

// groupByCategory groups results by category.
func (pw *PDFWriter) groupByCategory(results []*events.ResultEvent) map[string][]*events.ResultEvent {
	grouped := make(map[string][]*events.ResultEvent)
	for _, r := range results {
		cat := r.Test.Category
		if cat == "" {
			cat = "uncategorized"
		}
		grouped[cat] = append(grouped[cat], r)
	}
	return grouped
}

// addFindingCard adds a styled finding card to the PDF.
func (pw *PDFWriter) addFindingCard(pdf *gofpdf.Fpdf, finding *events.ResultEvent, num int) {
	pageW, _ := pdf.GetPageSize()
	cardW := pageW - 30
	startY := pdf.GetY()

	// Card background
	pdf.SetFillColor(250, 250, 250)
	pdf.Rect(15, startY, cardW, 8, "F")

	// Severity indicator stripe
	sevColor := pdfSeverityColors[string(finding.Test.Severity)]
	if sevColor == nil {
		sevColor = []int{128, 128, 128}
	}
	pdf.SetFillColor(sevColor[0], sevColor[1], sevColor[2])
	pdf.Rect(15, startY, 3, 8, "F")

	// Finding ID and name with severity icon
	pdf.SetFont("Helvetica", "B", 11)
	pdf.SetTextColor(30, 41, 59)
	pdf.SetXY(20, startY+1)
	var icon string
	switch finding.Test.Severity {
	case events.SeverityCritical:
		icon = "[!]"
	case events.SeverityHigh:
		icon = "[!]"
	case events.SeverityMedium:
		icon = "[*]"
	case events.SeverityLow:
		icon = "[-]"
	default:
		icon = "[i]"
	}
	title := fmt.Sprintf("%s #%d - %s", icon, num, finding.Test.ID)
	if finding.Test.Name != "" {
		title = fmt.Sprintf("%s #%d - %s: %s", icon, num, finding.Test.ID, finding.Test.Name)
	}
	pdf.CellFormat(cardW-60, 6, truncateString(title, 70), "", 0, "L", false, 0, "")

	// Severity badge
	pdf.SetXY(pageW-45, startY+1)
	pdf.SetFillColor(sevColor[0], sevColor[1], sevColor[2])
	pdf.SetTextColor(255, 255, 255)
	pdf.SetFont("Helvetica", "B", 9)
	pdf.CellFormat(25, 6, strings.ToUpper(string(finding.Test.Severity)), "0", 0, "C", true, 0, "")

	pdf.SetY(startY + 10)

	// Details table
	pdf.SetFont("Helvetica", "", 9)
	pdf.SetTextColor(80, 80, 80)

	details := []struct {
		label string
		value string
	}{
		{"URL", finding.Target.URL},
		{"Method", finding.Target.Method},
		{"Status", fmt.Sprintf("%d", finding.Result.StatusCode)},
		{"Latency", fmt.Sprintf("%.1f ms", finding.Result.LatencyMs)},
	}

	if len(finding.Test.OWASP) > 0 {
		details = append(details, struct{ label, value string }{
			"OWASP", strings.Join(finding.Test.OWASP, ", "),
		})
	}

	for _, d := range details {
		pdf.SetFont("Helvetica", "B", 9)
		pdf.CellFormat(25, 5, d.label+":", "", 0, "L", false, 0, "")
		pdf.SetFont("Helvetica", "", 9)
		pdf.CellFormat(0, 5, truncateString(d.value, 80), "", 1, "L", false, 0, "")
	}

	// Evidence section
	if pw.config.IncludeEvidence && finding.Evidence != nil {
		pdf.Ln(2)

		if finding.Evidence.Payload != "" {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Payload:", "", 0, "L", false, 0, "")
			pdf.SetFont("Courier", "", 8)
			pdf.SetTextColor(100, 100, 100)
			payload := truncateString(finding.Evidence.Payload, 90)
			pdf.MultiCell(cardW-25, 4, payload, "", "L", false)
			pdf.SetTextColor(80, 80, 80)
		}

		if finding.Evidence.CurlCommand != "" {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Curl:", "", 1, "L", false, 0, "")
			pdf.SetFont("Courier", "", 7)
			pdf.SetTextColor(100, 100, 100)
			curl := truncateString(finding.Evidence.CurlCommand, 120)
			pdf.MultiCell(cardW, 3, curl, "", "L", false)
			pdf.SetTextColor(80, 80, 80)
		}
	}

	// Add some space after the card
	pdf.Ln(3)
}

// setupHeaderFooter configures page headers and footers for all pages except cover.
func (pw *PDFWriter) setupHeaderFooter(pdf *gofpdf.Fpdf, pageW, pageH float64) {
	// Header
	pdf.SetHeaderFunc(func() {
		if pdf.PageNo() > 1 { // Skip cover page
			pdf.SetFont("Helvetica", "", 8)
			pdf.SetTextColor(128, 128, 128)
			pdf.SetY(5)
			pdf.CellFormat(0, 5, pw.config.Title, "", 0, "L", false, 0, "")
			if pw.config.Classification != "" {
				pdf.SetXY(pageW-50, 5)
				pdf.CellFormat(35, 5, strings.ToUpper(pw.config.Classification), "", 0, "R", false, 0, "")
			}
			pdf.Ln(3)
			pdf.SetDrawColor(200, 200, 200)
			pdf.Line(15, 12, pageW-15, 12)

			// Add watermark if configured
			pw.addWatermark(pdf, pageW, pageH)
		}
	})

	// Footer
	pdf.SetFooterFunc(func() {
		if pdf.PageNo() > 1 { // Skip cover page
			pdf.SetY(-15)
			pdf.SetDrawColor(200, 200, 200)
			pdf.Line(15, pageH-18, pageW-15, pageH-18)
			pdf.SetFont("Helvetica", "I", 8)
			pdf.SetTextColor(128, 128, 128)
			footerText := pw.config.FooterText
			if footerText == "" {
				footerText = "Generated by WAFtester"
			}
			pdf.CellFormat(0, 10, footerText, "", 0, "L", false, 0, "")
			pdf.CellFormat(0, 10, fmt.Sprintf("Page %d", pdf.PageNo()), "", 0, "R", false, 0, "")
		}
	})
}

// addWatermark adds a diagonal watermark to the current page.
func (pw *PDFWriter) addWatermark(pdf *gofpdf.Fpdf, pageW, pageH float64) {
	if pw.config.WatermarkText == "" {
		return
	}

	pdf.SetFont("Helvetica", "B", 60)
	pdf.SetTextColor(240, 240, 240) // Very light gray

	// Rotate text diagonally
	pdf.TransformBegin()
	pdf.TransformRotate(-45, pageW/2, pageH/2)

	textW := pdf.GetStringWidth(pw.config.WatermarkText)
	pdf.SetXY((pageW-textW)/2, pageH/2)
	pdf.CellFormat(textW, 20, pw.config.WatermarkText, "", 0, "C", false, 0, "")

	pdf.TransformEnd()
}

// addTableOfContents creates a professional table of contents.
func (pw *PDFWriter) addTableOfContents(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	// TOC Header
	pdf.SetFont("Helvetica", "B", 20)
	pdf.SetTextColor(30, 41, 59)
	pdf.CellFormat(0, 15, "Table of Contents", "", 1, "L", false, 0, "")
	pdf.Ln(5)

	// TOC entries - base pages
	entries := []struct {
		Title string
		Page  int
	}{
		{"Executive Summary", 3},
		{"OWASP Top 10 Coverage", 4},
		{"Detailed Findings", 5},
	}

	// Count findings pages dynamically
	bypasses := pw.getBypassResults()
	byCategory := pw.groupByCategory(bypasses)

	// Get sorted category names for consistent ordering
	categories := make([]string, 0, len(byCategory))
	for cat := range byCategory {
		categories = append(categories, cat)
	}
	sort.Strings(categories)

	pageNum := 5
	for _, cat := range categories {
		entries = append(entries, struct {
			Title string
			Page  int
		}{
			fmt.Sprintf("Findings: %s", strings.ToUpper(cat)),
			pageNum,
		})
		pageNum++
	}

	// Add methodology appendix
	entries = append(entries, struct {
		Title string
		Page  int
	}{"Appendix: Testing Methodology", pageNum})

	pageW, _ := pdf.GetPageSize()
	contentW := pageW - 30 // Account for margins

	for _, entry := range entries {
		pdf.SetFont("Helvetica", "", 12)
		pdf.SetTextColor(60, 60, 60)

		titleW := pdf.GetStringWidth(entry.Title)
		pageStr := fmt.Sprintf("%d", entry.Page)
		pageNumW := pdf.GetStringWidth(pageStr)

		// Title
		pdf.CellFormat(titleW, 8, entry.Title, "", 0, "L", false, 0, "")

		// Dotted leader
		dotWidth := contentW - titleW - pageNumW - 10
		if dotWidth > 0 {
			dots := strings.Repeat(".", int(dotWidth/2))
			pdf.SetTextColor(180, 180, 180)
			pdf.CellFormat(dotWidth, 8, dots, "", 0, "C", false, 0, "")
		}

		// Page number
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(pageNumW, 8, pageStr, "", 1, "R", false, 0, "")
	}
}

// addSeverityBarChart creates a horizontal bar chart for severity breakdown.
func (pw *PDFWriter) addSeverityBarChart(pdf *gofpdf.Fpdf, severityCounts map[string]int) {
	if len(severityCounts) == 0 {
		return
	}

	pdf.Ln(5)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Severity Distribution", "", 1, "L", false, 0, "")

	maxCount := 0
	for _, count := range severityCounts {
		if count > maxCount {
			maxCount = count
		}
	}
	if maxCount == 0 {
		maxCount = 1
	}

	barMaxWidth := 100.0
	severities := []string{"critical", "high", "medium", "low", "info"}

	for _, sev := range severities {
		count := severityCounts[sev]
		if count == 0 {
			continue
		}

		color := pdfSeverityColors[sev]
		if color == nil {
			color = []int{128, 128, 128}
		}
		barWidth := float64(count) / float64(maxCount) * barMaxWidth

		// Label
		pdf.SetFont("Helvetica", "", 10)
		pdf.SetTextColor(80, 80, 80)
		pdf.CellFormat(25, 7, cases.Title(language.English).String(sev), "", 0, "R", false, 0, "")

		// Bar
		pdf.SetFillColor(color[0], color[1], color[2])
		y := pdf.GetY()
		pdf.Rect(45, y+1, barWidth, 5, "F")

		// Count
		pdf.SetX(150)
		pdf.CellFormat(20, 7, fmt.Sprintf("%d", count), "", 1, "L", false, 0, "")
	}
}

// addRiskGauge creates a semi-circular gauge showing block rate.
func (pw *PDFWriter) addRiskGauge(pdf *gofpdf.Fpdf, blockRate float64) {
	// Draw a semi-circular gauge
	cx, cy := 100.0, pdf.GetY()+40
	radius := 30.0

	// Background arc (gray)
	pdf.SetDrawColor(220, 220, 220)
	pdf.SetLineWidth(8)
	pdf.Arc(cx, cy, radius, radius, 0, 180, 180, "D")

	// Calculate angle for block rate
	angle := blockRate * 1.8 // 0-100% maps to 0-180 degrees

	// Foreground arc (colored by score)
	var r, g, b int
	if blockRate >= 80 {
		r, g, b = 22, 163, 74 // Green
	} else if blockRate >= 60 {
		r, g, b = 202, 138, 4 // Yellow
	} else {
		r, g, b = 220, 38, 38 // Red
	}

	pdf.SetDrawColor(r, g, b)
	if angle > 0 {
		pdf.Arc(cx, cy, radius, radius, 0, 180-angle, 180, "D")
	}

	pdf.SetLineWidth(0.2)

	// Center text
	pdf.SetFont("Helvetica", "B", 20)
	pdf.SetTextColor(r, g, b)
	pdf.SetXY(cx-25, cy-10)
	pdf.CellFormat(50, 20, fmt.Sprintf("%.0f%%", blockRate), "", 0, "C", false, 0, "")

	pdf.SetY(cy + 15)
}

// addMethodologyAppendix adds an appendix explaining testing methodology.
func (pw *PDFWriter) addMethodologyAppendix(pdf *gofpdf.Fpdf) {
	pdf.AddPage()
	pw.addSectionHeader(pdf, "Appendix: Testing Methodology")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(60, 60, 60)

	methodology := `WAFtester performs comprehensive Web Application Firewall testing using the following methodology:

1. ATTACK SIMULATION
   - Sends known attack payloads (SQL injection, XSS, etc.)
   - Tests against OWASP Top 10 categories
   - Uses evasion techniques to bypass signatures

2. RESPONSE ANALYSIS
   - Analyzes HTTP response codes
   - Detects blocking pages and error responses
   - Measures response timing for fingerprinting

3. EFFECTIVENESS SCORING
   - Calculates block rate (blocked / total tests)
   - Assigns letter grade based on coverage
   - Identifies gaps in WAF protection

4. SEVERITY CLASSIFICATION
   - Critical: Exploitable with high impact
   - High: Significant security risk
   - Medium: Moderate security concern
   - Low: Minor security issue
   - Info: Informational finding`

	pdf.MultiCell(0, 5, methodology, "", "L", false)

	// Add additional info
	pdf.Ln(10)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(30, 41, 59)
	pdf.CellFormat(0, 10, "Grading Scale", "", 1, "L", false, 0, "")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(60, 60, 60)

	grades := `A+ (97-100%): Exceptional - Almost all attacks blocked
A  (93-96%):  Excellent - Very strong WAF protection
A- (90-92%):  Very Good - Strong protection with minor gaps
B+ (87-89%):  Good - Solid protection, some improvements needed
B  (83-86%):  Above Average - Moderate protection
B- (80-82%):  Satisfactory - Basic protection in place
C+ (77-79%):  Fair - Noticeable gaps in coverage
C  (73-76%):  Passing - Significant improvements needed
C- (70-72%):  Marginal - Many attacks getting through
D  (60-69%):  Poor - Weak WAF configuration
F  (<60%):    Failing - Critical security gaps`

	pdf.MultiCell(0, 5, grades, "", "L", false)
}
