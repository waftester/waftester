// Package writers provides output writers for various formats.
package writers

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"sync"
	"time"

	gofpdf "github.com/go-pdf/fpdf"
	"github.com/waftester/waftester/pkg/defaults"
	"github.com/waftester/waftester/pkg/output/dispatcher"
	"github.com/waftester/waftester/pkg/output/events"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// Compile-time interface check.
var _ dispatcher.Writer = (*PDFWriter)(nil)

// pdfSeverityColors maps severity levels to RGB color values.
var pdfSeverityColors = map[string][]int{
	"critical": {220, 38, 38}, // Red
	"high":     {234, 88, 12}, // Orange
	"medium":   {202, 138, 4}, // Yellow
	"low":      {22, 163, 74}, // Green
	"info":     {37, 99, 235}, // Blue
}

// PDFConfig configures the PDF report writer.
type PDFConfig struct {
	// Title is the report title (default: "WAFtester Security Report")
	Title string

	// CompanyName is the company name for branding (optional)
	CompanyName string

	// CompanyLogo is the path to company logo (PNG/JPG) (optional)
	CompanyLogo string

	// Author is the report author (optional)
	Author string

	// IncludeEvidence includes payload and curl command in findings (default: true)
	IncludeEvidence bool

	// PageSize sets the page size: "A4" or "Letter" (default: "A4")
	PageSize string

	// Orientation sets page orientation: "P" (portrait) or "L" (landscape) (default: "P")
	Orientation string

	// Classification sets the document classification (CONFIDENTIAL, INTERNAL, PUBLIC)
	Classification string

	// IncludeTOC adds table of contents (default: true)
	IncludeTOC bool

	// WatermarkText adds a diagonal watermark to all pages (optional)
	WatermarkText string

	// FooterText customizes the footer text (default: "Generated by WAFtester")
	FooterText string
}

// pdfOWASPStat holds OWASP category counts for the PDF OWASP table.
type pdfOWASPStat struct {
	Total    int
	Bypasses int
}

// PDFWriter writes events as a styled PDF report.
// It buffers all events in memory and renders the complete PDF document on Close.
// The writer is safe for concurrent use.
// All Write calls must complete before Close is called.
type PDFWriter struct {
	w          io.Writer
	mu         sync.Mutex
	closed     bool
	noCompress bool // disables stream compression (test-only)
	config     PDFConfig
	results    []*events.ResultEvent
	summary    *events.SummaryEvent
	start      *events.StartEvent
}

// NewPDFWriter creates a new PDF report writer.
// The writer buffers all events and writes a complete PDF report on Close.
func NewPDFWriter(w io.Writer, config PDFConfig) *PDFWriter {
	if config.Title == "" {
		config.Title = "WAFtester Security Report"
	}
	if config.PageSize == "" {
		config.PageSize = "A4"
	}
	if config.Orientation == "" {
		config.Orientation = "P"
	}
	return &PDFWriter{
		w:       w,
		config:  config,
		results: make([]*events.ResultEvent, 0),
	}
}

// Write buffers an event for later PDF output.
// Returns an error if Close has already been called.
func (pw *PDFWriter) Write(event events.Event) error {
	pw.mu.Lock()
	defer pw.mu.Unlock()

	if pw.closed {
		return fmt.Errorf("pdf writer: write after close")
	}

	switch e := event.(type) {
	case *events.ResultEvent:
		pw.results = append(pw.results, e)
	case *events.SummaryEvent:
		pw.summary = e
	case *events.StartEvent:
		pw.start = e
	}
	return nil
}

// Flush is a no-op for PDF writer.
// All events are written as a single PDF document on Close.
func (pw *PDFWriter) Flush() error {
	return nil
}

// Close renders and writes the complete PDF report.
// All Write calls must complete before Close is called.
func (pw *PDFWriter) Close() error {
	pw.mu.Lock()
	defer pw.mu.Unlock()

	pw.closed = true

	// Pre-compute bypass results once for TOC and findings.
	bypasses := pw.getBypassResults()
	byCategory := pw.groupByCategory(bypasses)

	pdf := pw.createPDF()
	pageW, pageH := pdf.GetPageSize()
	pw.setupHeaderFooter(pdf, pageW, pageH)

	pw.addCoverPage(pdf)
	if pw.config.IncludeTOC {
		pw.addTableOfContents(pdf, byCategory)
	}
	pw.addExecutiveSummary(pdf)
	pw.addTopBypasses(pdf)
	pw.addCategoryBreakdown(pdf)
	pw.addOWASPTable(pdf)
	pw.addFindingsSectionFromGroups(pdf, bypasses, byCategory)
	pw.addScanConfiguration(pdf)
	pw.addMethodologyAppendix(pdf)

	return pdf.Output(pw.w)
}

// SupportsEvent returns true for result and summary events.
func (pw *PDFWriter) SupportsEvent(eventType events.EventType) bool {
	switch eventType {
	case events.EventTypeResult, events.EventTypeSummary, events.EventTypeStart:
		return true
	default:
		return false
	}
}

// createPDF initializes a new PDF document with the configured settings.
func (pw *PDFWriter) createPDF() *gofpdf.Fpdf {
	pdf := gofpdf.New(pw.config.Orientation, "mm", pw.config.PageSize, "")

	if pw.noCompress {
		pdf.SetCompression(false)
	}

	// Set document info
	pdf.SetTitle(pw.config.Title, true)
	if pw.config.Author != "" {
		pdf.SetAuthor(pw.config.Author, true)
	}
	pdf.SetCreator("WAFtester", true)
	pdf.SetCreationDate(time.Now())

	// Set margins
	pdf.SetMargins(15, 15, 15)
	pdf.SetAutoPageBreak(true, 20)

	return pdf
}

// addCoverPage creates the professional cover page.
func (pw *PDFWriter) addCoverPage(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	// Get page dimensions
	pageW, pageH := pdf.GetPageSize()

	// Background color header strip
	pdf.SetFillColor(30, 41, 59) // Slate-800
	pdf.Rect(0, 0, pageW, 80, "F")

	// Company logo if provided
	if pw.config.CompanyLogo != "" {
		// Try to add the logo - if it fails, we just skip it
		pdf.ImageOptions(pw.config.CompanyLogo, pageW-60, 15, 45, 0, false,
			gofpdf.ImageOptions{ReadDpi: true}, 0, "")
	}

	// Title
	pdf.SetFont("Helvetica", "B", 28)
	pdf.SetTextColor(255, 255, 255)
	pdf.SetXY(15, 25)
	pdf.CellFormat(pageW-80, 15, pw.config.Title, "", 1, "L", false, 0, "")

	// Classification badge
	pdf.SetY(60)
	pdf.SetFont("Helvetica", "B", 10)
	pdf.SetFillColor(220, 38, 38) // Red for CONFIDENTIAL
	pdf.SetTextColor(255, 255, 255)
	classification := "CONFIDENTIAL"
	if pw.config.Classification != "" {
		classification = strings.ToUpper(pw.config.Classification)
	}
	if classification == "INTERNAL" {
		pdf.SetFillColor(202, 138, 4) // Yellow for INTERNAL
	} else if classification == "PUBLIC" {
		pdf.SetFillColor(22, 163, 74) // Green for PUBLIC
	}
	badgeW := pdf.GetStringWidth(classification) + 12
	pdf.SetX((pageW - badgeW) / 2)
	pdf.CellFormat(badgeW, 8, classification, "", 1, "C", true, 0, "")

	// Company name if provided
	if pw.config.CompanyName != "" {
		pdf.SetFont("Helvetica", "", 14)
		pdf.SetTextColor(200, 200, 200)
		pdf.SetXY(15, 45)
		pdf.CellFormat(pageW-30, 10, pw.config.CompanyName, "", 1, "L", false, 0, "")
	}

	// Target and date info box
	pdf.SetFont("Helvetica", "", 12)
	pdf.SetTextColor(60, 60, 60)

	targetURL := "Unknown"
	wafDetected := "Unknown"
	scanDate := time.Now().Format("2006-01-02 15:04 MST")

	if pw.summary != nil {
		targetURL = pw.summary.Target.URL
		if pw.summary.Target.WAFDetected != "" {
			wafDetected = pw.summary.Target.WAFDetected
		}
		if !pw.summary.Timing.StartedAt.IsZero() {
			scanDate = pw.summary.Timing.StartedAt.Format("2006-01-02 15:04 MST")
		}
	}

	// Info section
	pdf.SetY(100)
	pw.addInfoRow(pdf, "Target URL:", truncateString(targetURL, 70))
	pw.addInfoRow(pdf, "WAF Detected:", wafDetected)
	if pw.summary != nil && pw.summary.Target.WAFConfidence > 0 {
		pw.addInfoRow(pdf, "WAF Confidence:", fmt.Sprintf("%.0f%%", pw.summary.Target.WAFConfidence*100))
	}
	pw.addInfoRow(pdf, "Scan Date:", scanDate)
	if pw.summary != nil && pw.summary.Timing.DurationSec > 0 {
		pw.addInfoRow(pdf, "Scan Duration:", formatDuration(pw.summary.Timing.DurationSec))
	}
	if pw.summary != nil && pw.summary.Timing.RequestsPerSec > 0 {
		pw.addInfoRow(pdf, "Throughput:", fmt.Sprintf("%.1f req/s", pw.summary.Timing.RequestsPerSec))
	}
	if pw.config.Author != "" {
		pw.addInfoRow(pdf, "Report Author:", pw.config.Author)
	}
	if pw.summary != nil && pw.summary.ExitReason != "" && pw.summary.ExitReason != "completed" {
		pw.addInfoRow(pdf, "Exit Reason:", pw.summary.ExitReason)
	}

	// Grade box - centered
	if pw.summary != nil {
		grade := pw.summary.Effectiveness.Grade
		gradeColor := pw.getGradeColor(grade)

		pdf.SetY(pageH/2 - 30)
		pdf.SetFont("Helvetica", "B", 16)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(pageW-30, 10, "WAF Effectiveness Grade", "", 1, "C", false, 0, "")

		// Grade circle
		pdf.SetFillColor(gradeColor[0], gradeColor[1], gradeColor[2])
		pdf.Circle(pageW/2, pageH/2+10, 30, "F")

		pdf.SetFont("Helvetica", "B", 48)
		pdf.SetTextColor(255, 255, 255)
		pdf.SetXY(0, pageH/2-5)
		pdf.CellFormat(pageW, 30, grade, "", 1, "C", false, 0, "")

		// Block rate
		pdf.SetFont("Helvetica", "", 14)
		pdf.SetTextColor(60, 60, 60)
		pdf.SetY(pageH/2 + 45)
		blockRate := fmt.Sprintf("Block Rate: %.1f%%", pw.summary.Effectiveness.BlockRatePct)
		pdf.CellFormat(pageW-30, 10, blockRate, "", 1, "C", false, 0, "")
	}

	// Footer
	pdf.SetY(pageH - 30)
	pdf.SetFont("Helvetica", "I", 10)
	pdf.SetTextColor(128, 128, 128)
	pdf.CellFormat(pageW-30, 8, "Generated by WAFtester - Web Application Firewall Testing Tool", "", 0, "C", false, 0, "")
}

// addInfoRow adds a label-value row to the PDF.
func (pw *PDFWriter) addInfoRow(pdf *gofpdf.Fpdf, label, value string) {
	pdf.SetFont("Helvetica", "B", 11)
	pdf.SetTextColor(80, 80, 80)
	pdf.CellFormat(40, 8, label, "", 0, "L", false, 0, "")
	pdf.SetFont("Helvetica", "", 11)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 8, value, "", 1, "L", false, 0, "")
}

// getGradeColor returns RGB color for the effectiveness grade.
func (pw *PDFWriter) getGradeColor(grade string) []int {
	switch grade {
	case "A+", "A", "A-":
		return []int{22, 163, 74} // Green
	case "B+", "B", "B-":
		return []int{37, 99, 235} // Blue
	case "C+", "C", "C-":
		return []int{202, 138, 4} // Yellow
	case "D+", "D", "D-":
		return []int{234, 88, 12} // Orange
	default:
		return []int{220, 38, 38} // Red (F)
	}
}

// addExecutiveSummary creates the executive summary section.
func (pw *PDFWriter) addExecutiveSummary(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	// Section header
	pw.addSectionHeader(pdf, "Executive Summary")

	if pw.summary == nil {
		pdf.SetFont("Helvetica", "I", 11)
		pdf.SetTextColor(128, 128, 128)
		pdf.CellFormat(0, 8, "No summary data available", "", 1, "L", false, 0, "")
		return
	}

	// Summary statistics table
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Test Statistics", "", 1, "L", false, 0, "")

	// Statistics grid â€” Passes (expected pass-through from false-positive testing)
	// is intentionally omitted since it's almost always zero in WAF attack scans.
	stats := []struct {
		label string
		value int
		color []int
	}{
		{"Total Tests", pw.summary.Totals.Tests, []int{60, 60, 60}},
		{"Blocked", pw.summary.Totals.Blocked, []int{22, 163, 74}},
		{"Bypasses", pw.summary.Totals.Bypasses, []int{220, 38, 38}},
		{"Errors", pw.summary.Totals.Errors, []int{202, 138, 4}},
		{"Timeouts", pw.summary.Totals.Timeouts, []int{37, 99, 235}},
	}

	pageW, _ := pdf.GetPageSize()
	cellW := (pageW - 30) / 5

	// Stat boxes
	startY := pdf.GetY() + 5
	for i, stat := range stats {
		x := 15 + float64(i)*cellW

		// Box background
		pdf.SetFillColor(245, 245, 245)
		pdf.Rect(x, startY, cellW-2, 25, "F")

		// Value
		pdf.SetFont("Helvetica", "B", 18)
		pdf.SetTextColor(stat.color[0], stat.color[1], stat.color[2])
		pdf.SetXY(x, startY+2)
		pdf.CellFormat(cellW-2, 12, fmt.Sprintf("%d", stat.value), "", 0, "C", false, 0, "")

		// Label
		pdf.SetFont("Helvetica", "", 9)
		pdf.SetTextColor(100, 100, 100)
		pdf.SetXY(x, startY+14)
		pdf.CellFormat(cellW-2, 8, stat.label, "", 0, "C", false, 0, "")
	}

	pdf.SetY(startY + 35)

	// Severity breakdown
	if len(pw.summary.Breakdown.BySeverity) > 0 {
		pdf.SetFont("Helvetica", "B", 12)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 10, "Findings by Severity", "", 1, "L", false, 0, "")

		// Count bypass findings by severity
		severityCounts := pw.countBypassesBySeverity()

		// Table header
		pdf.SetFont("Helvetica", "B", 10)
		pdf.SetFillColor(240, 240, 240)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(50, 8, "Severity", "1", 0, "C", true, 0, "")
		pdf.CellFormat(40, 8, "Bypasses", "1", 0, "C", true, 0, "")
		pdf.CellFormat(40, 8, "Total", "1", 0, "C", true, 0, "")
		pdf.CellFormat(40, 8, "Block Rate", "1", 1, "C", true, 0, "")

		// Table rows
		pdf.SetFont("Helvetica", "", 10)
		severityOrder := []string{"critical", "high", "medium", "low", "info"}
		for _, sev := range severityOrder {
			stats, exists := pw.summary.Breakdown.BySeverity[sev]
			if !exists {
				continue
			}

			color := pdfSeverityColors[sev]
			pdf.SetTextColor(color[0], color[1], color[2])
			pdf.CellFormat(50, 7, cases.Title(language.English).String(sev), "1", 0, "L", false, 0, "")

			bypassCount := severityCounts[sev]
			pdf.SetTextColor(60, 60, 60)
			pdf.CellFormat(40, 7, fmt.Sprintf("%d", bypassCount), "1", 0, "C", false, 0, "")
			pdf.CellFormat(40, 7, fmt.Sprintf("%d", stats.Total), "1", 0, "C", false, 0, "")
			pdf.CellFormat(40, 7, fmt.Sprintf("%.1f%%", stats.BlockRate), "1", 1, "C", false, 0, "")
		}

		// Add severity distribution bar chart
		pw.addSeverityBarChart(pdf, severityCounts)
	}

	// Add risk gauge visualization
	if pw.summary.Effectiveness.BlockRatePct >= 0 {
		pdf.Ln(10)
		pdf.SetFont("Helvetica", "B", 12)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 10, "WAF Protection Score", "", 1, "L", false, 0, "")
		pw.addRiskGauge(pdf, pw.summary.Effectiveness.BlockRatePct)
	}

	// Recommendation
	if pw.summary.Effectiveness.Recommendation != "" {
		pdf.Ln(10)
		pdf.SetFont("Helvetica", "B", 12)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 10, "Recommendation", "", 1, "L", false, 0, "")

		pdf.SetFont("Helvetica", "", 11)
		pdf.SetTextColor(80, 80, 80)
		pdf.MultiCell(0, 6, pw.summary.Effectiveness.Recommendation, "", "L", false)
	}

	// Latency profile
	pw.addLatencyProfile(pdf)
}

// countBypassesBySeverity counts bypass results by severity from buffered results.
func (pw *PDFWriter) countBypassesBySeverity() map[string]int {
	counts := make(map[string]int)
	for _, r := range pw.results {
		if r.Result.Outcome == events.OutcomeBypass {
			sev := string(r.Test.Severity)
			counts[sev]++
		}
	}
	return counts
}

// addSectionHeader adds a styled section header.
func (pw *PDFWriter) addSectionHeader(pdf *gofpdf.Fpdf, title string) {
	pdf.SetFont("Helvetica", "B", 18)
	pdf.SetTextColor(30, 41, 59) // Slate-800
	pdf.CellFormat(0, 12, title, "", 1, "L", false, 0, "")

	// Underline
	pdf.SetDrawColor(30, 41, 59)
	pdf.SetLineWidth(0.5)
	pageW, _ := pdf.GetPageSize()
	y := pdf.GetY()
	pdf.Line(15, y, pageW-15, y)
	pdf.Ln(8)
}

// OWASP Top 10 2021 reference data - uses defaults.OWASPTop10 and defaults.OWASPTop10Ordered.

// addOWASPTable creates the OWASP Top 10 mapping table.
func (pw *PDFWriter) addOWASPTable(pdf *gofpdf.Fpdf) {
	pdf.AddPage()

	pw.addSectionHeader(pdf, "OWASP Top 10 Coverage")

	// Build OWASP stats from results
	owaspStats := pw.buildOWASPStats()

	// Table header
	pdf.SetFont("Helvetica", "B", 10)
	pdf.SetFillColor(30, 41, 59) // Dark header
	pdf.SetTextColor(255, 255, 255)
	pdf.CellFormat(25, 8, "Code", "1", 0, "C", true, 0, "")
	pdf.CellFormat(70, 8, "Category", "1", 0, "L", true, 0, "")
	pdf.CellFormat(25, 8, "Tests", "1", 0, "C", true, 0, "")
	pdf.CellFormat(25, 8, "Bypasses", "1", 0, "C", true, 0, "")
	pdf.CellFormat(30, 8, "Status", "1", 1, "C", true, 0, "")

	// Table rows
	pdf.SetFont("Helvetica", "", 10)
	for _, code := range defaults.OWASPTop10Ordered {
		cat := defaults.OWASPTop10[code]
		stats := owaspStats[code]

		pdf.SetTextColor(60, 60, 60)
		pdf.SetFillColor(250, 250, 250)
		pdf.CellFormat(25, 7, code, "1", 0, "C", true, 0, "")
		pdf.CellFormat(70, 7, cat.Name, "1", 0, "L", true, 0, "")
		pdf.CellFormat(25, 7, fmt.Sprintf("%d", stats.Total), "1", 0, "C", true, 0, "")

		// Bypasses with color
		if stats.Bypasses > 0 {
			pdf.SetTextColor(220, 38, 38)
		}
		pdf.CellFormat(25, 7, fmt.Sprintf("%d", stats.Bypasses), "1", 0, "C", true, 0, "")
		pdf.SetTextColor(60, 60, 60)

		// Status badge
		status := "N/A"
		statusColor := []int{128, 128, 128}
		if stats.Total > 0 {
			if stats.Bypasses == 0 {
				status = "PASS"
				statusColor = []int{22, 163, 74}
			} else {
				status = "FAIL"
				statusColor = []int{220, 38, 38}
			}
		}
		pdf.SetTextColor(statusColor[0], statusColor[1], statusColor[2])
		pdf.SetFont("Helvetica", "B", 10)
		pdf.CellFormat(30, 7, status, "1", 1, "C", true, 0, "")
		pdf.SetFont("Helvetica", "", 10)
	}
}

// buildOWASPStats builds OWASP statistics from buffered results.
func (pw *PDFWriter) buildOWASPStats() map[string]*pdfOWASPStat {
	stats := make(map[string]*pdfOWASPStat)

	// Initialize all OWASP categories using centralized data
	for _, code := range defaults.OWASPTop10Ordered {
		stats[code] = &pdfOWASPStat{}
	}

	// Count from results
	for _, r := range pw.results {
		for _, owaspCode := range r.Test.OWASP {
			if s, ok := stats[owaspCode]; ok {
				s.Total++
				if r.Result.Outcome == events.OutcomeBypass {
					s.Bypasses++
				}
			}
		}
	}

	// Also include summary data if available
	if pw.summary != nil && pw.summary.Breakdown.ByOWASP != nil {
		for code, summaryStats := range pw.summary.Breakdown.ByOWASP {
			if s, ok := stats[code]; ok {
				// Use summary data if we have no results
				if s.Total == 0 {
					s.Total = summaryStats.Total
					s.Bypasses = summaryStats.Bypasses
				}
			}
		}
	}

	return stats
}

// addFindingsSectionFromGroups renders findings from pre-computed bypass groups.
// If byCategory is nil it is computed from bypasses.
func (pw *PDFWriter) addFindingsSectionFromGroups(pdf *gofpdf.Fpdf, bypasses []*events.ResultEvent, byCategory map[string][]*events.ResultEvent) {
	if len(bypasses) == 0 {
		pdf.AddPage()
		pw.addSectionHeader(pdf, "Detailed Findings")
		pdf.SetFont("Helvetica", "I", 11)
		pdf.SetTextColor(100, 100, 100)
		pdf.CellFormat(0, 8, "No bypass vulnerabilities detected.", "", 1, "L", false, 0, "")
		return
	}

	if byCategory == nil {
		byCategory = pw.groupByCategory(bypasses)
	}

	// Get sorted category names
	categories := make([]string, 0, len(byCategory))
	for cat := range byCategory {
		categories = append(categories, cat)
	}
	sort.Strings(categories)

	_, pageH := pdf.GetPageSize()
	pageBreakY := pageH - 47 // footer + margin + buffer

	for _, category := range categories {
		findings := byCategory[category]

		pdf.AddPage()
		pw.addSectionHeader(pdf, fmt.Sprintf("Findings: %s", strings.ToUpper(category)))

		for i, finding := range findings {
			if i > 0 {
				pdf.Ln(5)
			}

			// Pre-render page break: a finding card needs roughly 80mm minimum.
			if pdf.GetY()+80 > pageBreakY {
				pdf.AddPage()
			}

			pw.addFindingCard(pdf, finding, i+1)
		}
	}
}

// getBypassResults filters for bypass-only results.
func (pw *PDFWriter) getBypassResults() []*events.ResultEvent {
	bypasses := make([]*events.ResultEvent, 0)
	for _, r := range pw.results {
		if r.Result.Outcome == events.OutcomeBypass {
			bypasses = append(bypasses, r)
		}
	}
	return bypasses
}

// groupByCategory groups results by category.
func (pw *PDFWriter) groupByCategory(results []*events.ResultEvent) map[string][]*events.ResultEvent {
	grouped := make(map[string][]*events.ResultEvent)
	for _, r := range results {
		cat := r.Test.Category
		if cat == "" {
			cat = "uncategorized"
		}
		grouped[cat] = append(grouped[cat], r)
	}
	return grouped
}

// addFindingCard adds a styled finding card to the PDF.
func (pw *PDFWriter) addFindingCard(pdf *gofpdf.Fpdf, finding *events.ResultEvent, num int) {
	pageW, _ := pdf.GetPageSize()
	cardW := pageW - 30
	startY := pdf.GetY()

	// Card background (8mm height coupled to the title + severity badge layout below)
	pdf.SetFillColor(250, 250, 250)
	pdf.Rect(15, startY, cardW, 8, "F")

	// Severity indicator stripe
	sevColor := pdfSeverityColors[string(finding.Test.Severity)]
	if sevColor == nil {
		sevColor = []int{128, 128, 128}
	}
	pdf.SetFillColor(sevColor[0], sevColor[1], sevColor[2])
	pdf.Rect(15, startY, 3, 8, "F")

	// Finding ID and name with severity icon
	pdf.SetFont("Helvetica", "B", 11)
	pdf.SetTextColor(30, 41, 59)
	pdf.SetXY(20, startY+1)
	var icon string
	switch finding.Test.Severity {
	case events.SeverityCritical:
		icon = "[!]"
	case events.SeverityHigh:
		icon = "[!]"
	case events.SeverityMedium:
		icon = "[*]"
	case events.SeverityLow:
		icon = "[-]"
	default:
		icon = "[i]"
	}
	title := fmt.Sprintf("%s #%d - %s", icon, num, finding.Test.ID)
	if finding.Test.Name != "" {
		title = fmt.Sprintf("%s #%d - %s: %s", icon, num, finding.Test.ID, finding.Test.Name)
	}
	pdf.CellFormat(cardW-60, 6, truncateString(title, 70), "", 0, "L", false, 0, "")

	// Severity badge
	pdf.SetXY(pageW-45, startY+1)
	pdf.SetFillColor(sevColor[0], sevColor[1], sevColor[2])
	pdf.SetTextColor(255, 255, 255)
	pdf.SetFont("Helvetica", "B", 9)
	pdf.CellFormat(25, 6, strings.ToUpper(string(finding.Test.Severity)), "0", 0, "C", true, 0, "")

	pdf.SetY(startY + 10)

	// Details table
	pdf.SetFont("Helvetica", "", 9)
	pdf.SetTextColor(80, 80, 80)

	details := []struct {
		label string
		value string
	}{
		{"URL", finding.Target.URL},
		{"Method", finding.Target.Method},
		{"Status", fmt.Sprintf("%d", finding.Result.StatusCode)},
		{"Latency", fmt.Sprintf("%.1f ms", finding.Result.LatencyMs)},
	}

	if finding.Result.ContentLength > 0 {
		details = append(details, struct{ label, value string }{
			"Size", fmt.Sprintf("%d bytes", finding.Result.ContentLength),
		})
	}

	if finding.Test.Subcategory != "" {
		details = append(details, struct{ label, value string }{
			"Subcategory", finding.Test.Subcategory,
		})
	}

	if len(finding.Test.OWASP) > 0 {
		details = append(details, struct{ label, value string }{
			"OWASP", strings.Join(finding.Test.OWASP, ", "),
		})
	}

	if len(finding.Test.CWE) > 0 {
		cweStrs := make([]string, len(finding.Test.CWE))
		for i, c := range finding.Test.CWE {
			cweStrs[i] = fmt.Sprintf("CWE-%d", c)
		}
		details = append(details, struct{ label, value string }{
			"CWE", strings.Join(cweStrs, ", "),
		})
	}

	if finding.Result.Confidence != "" {
		note := string(finding.Result.Confidence)
		if finding.Result.ConfidenceNote != "" {
			note += " (" + finding.Result.ConfidenceNote + ")"
		}
		details = append(details, struct{ label, value string }{
			"Confidence", note,
		})
	}

	if finding.Result.WAFSignature != "" {
		details = append(details, struct{ label, value string }{
			"WAF Rule", finding.Result.WAFSignature,
		})
	}

	if len(finding.Test.Tags) > 0 {
		details = append(details, struct{ label, value string }{
			"Tags", strings.Join(finding.Test.Tags, ", "),
		})
	}

	// Evasion context
	if finding.Context != nil {
		if finding.Context.Phase != "" {
			details = append(details, struct{ label, value string }{
				"Phase", finding.Context.Phase,
			})
		}
		if finding.Context.EvasionTechnique != "" {
			details = append(details, struct{ label, value string }{
				"Evasion", finding.Context.EvasionTechnique,
			})
		}
		if finding.Context.Tamper != "" {
			details = append(details, struct{ label, value string }{
				"Tamper", finding.Context.Tamper,
			})
		}
		if finding.Context.Encoding != "" {
			details = append(details, struct{ label, value string }{
				"Encoding", finding.Context.Encoding,
			})
		}
	}

	if finding.Target.Endpoint != "" {
		details = append(details, struct{ label, value string }{
			"Endpoint", finding.Target.Endpoint,
		})
	}
	if finding.Target.Parameter != "" {
		details = append(details, struct{ label, value string }{
			"Parameter", finding.Target.Parameter,
		})
	}

	for _, d := range details {
		pdf.SetFont("Helvetica", "B", 9)
		pdf.CellFormat(25, 5, d.label+":", "", 0, "L", false, 0, "")
		pdf.SetFont("Helvetica", "", 9)
		pdf.CellFormat(0, 5, truncateString(d.value, 80), "", 1, "L", false, 0, "")
	}

	// Evidence section
	if pw.config.IncludeEvidence && finding.Evidence != nil {
		pdf.Ln(2)

		if finding.Evidence.Payload != "" {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Payload:", "", 0, "L", false, 0, "")
			pdf.SetFont("Courier", "", 8)
			pdf.SetTextColor(100, 100, 100)
			payload := truncateString(finding.Evidence.Payload, 90)
			pdf.MultiCell(cardW-25, 4, payload, "", "L", false)
			pdf.SetTextColor(80, 80, 80)
		}

		if finding.Evidence.EncodedPayload != "" {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Encoded:", "", 0, "L", false, 0, "")
			pdf.SetFont("Courier", "", 8)
			pdf.SetTextColor(100, 100, 100)
			encoded := truncateString(finding.Evidence.EncodedPayload, 90)
			pdf.MultiCell(cardW-25, 4, encoded, "", "L", false)
			pdf.SetTextColor(80, 80, 80)
		}

		if len(finding.Evidence.RequestHeaders) > 0 {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Headers:", "", 1, "L", false, 0, "")
			pdf.SetFont("Courier", "", 7)
			pdf.SetTextColor(100, 100, 100)
			hdrKeys := make([]string, 0, len(finding.Evidence.RequestHeaders))
			for k := range finding.Evidence.RequestHeaders {
				hdrKeys = append(hdrKeys, k)
			}
			sort.Strings(hdrKeys)
			for _, hdr := range hdrKeys {
				line := truncateString(fmt.Sprintf("%s: %s", hdr, finding.Evidence.RequestHeaders[hdr]), 100)
				pdf.CellFormat(0, 3.5, "  "+line, "", 1, "L", false, 0, "")
			}
			pdf.SetTextColor(80, 80, 80)
		}

		if finding.Evidence.CurlCommand != "" {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Curl:", "", 1, "L", false, 0, "")
			pdf.SetFont("Courier", "", 7)
			pdf.SetTextColor(100, 100, 100)
			curl := truncateString(finding.Evidence.CurlCommand, 120)
			pdf.MultiCell(cardW, 3, curl, "", "L", false)
			pdf.SetTextColor(80, 80, 80)
		}

		if finding.Evidence.ResponsePreview != "" {
			pdf.SetFont("Helvetica", "B", 9)
			pdf.CellFormat(25, 5, "Response:", "", 1, "L", false, 0, "")
			pdf.SetFont("Courier", "", 7)
			pdf.SetTextColor(100, 100, 100)
			preview := truncateString(finding.Evidence.ResponsePreview, 200)
			pdf.MultiCell(cardW, 3, preview, "", "L", false)
			pdf.SetTextColor(80, 80, 80)
		}
	}

	// Add some space after the card
	pdf.Ln(3)
}

// setupHeaderFooter configures page headers and footers for all pages except cover.
func (pw *PDFWriter) setupHeaderFooter(pdf *gofpdf.Fpdf, pageW, pageH float64) {
	// Header
	pdf.SetHeaderFunc(func() {
		if pdf.PageNo() > 1 { // Skip cover page
			pdf.SetFont("Helvetica", "", 8)
			pdf.SetTextColor(128, 128, 128)
			pdf.SetY(5)
			pdf.CellFormat(0, 5, pw.config.Title, "", 0, "L", false, 0, "")
			if pw.config.Classification != "" {
				pdf.SetXY(pageW-50, 5)
				pdf.CellFormat(35, 5, strings.ToUpper(pw.config.Classification), "", 0, "R", false, 0, "")
			}
			pdf.Ln(3)
			pdf.SetDrawColor(200, 200, 200)
			pdf.Line(15, 12, pageW-15, 12)

			// Add watermark if configured
			pw.addWatermark(pdf, pageW, pageH)
		}
	})

	// Footer
	pdf.SetFooterFunc(func() {
		if pdf.PageNo() > 1 { // Skip cover page
			pdf.SetY(-15)
			pdf.SetDrawColor(200, 200, 200)
			pdf.Line(15, pageH-18, pageW-15, pageH-18)
			pdf.SetFont("Helvetica", "I", 8)
			pdf.SetTextColor(128, 128, 128)
			footerText := pw.config.FooterText
			if footerText == "" {
				footerText = "Generated by WAFtester"
			}
			pdf.CellFormat(0, 10, footerText, "", 0, "L", false, 0, "")
			pdf.CellFormat(0, 10, fmt.Sprintf("Page %d", pdf.PageNo()), "", 0, "R", false, 0, "")
		}
	})
}

// addWatermark adds a diagonal watermark to the current page.
func (pw *PDFWriter) addWatermark(pdf *gofpdf.Fpdf, pageW, pageH float64) {
	if pw.config.WatermarkText == "" {
		return
	}

	pdf.SetFont("Helvetica", "B", 60)
	pdf.SetTextColor(240, 240, 240) // Very light gray

	// Rotate text diagonally
	pdf.TransformBegin()
	pdf.TransformRotate(-45, pageW/2, pageH/2)

	textW := pdf.GetStringWidth(pw.config.WatermarkText)
	pdf.SetXY((pageW-textW)/2, pageH/2)
	pdf.CellFormat(textW, 20, pw.config.WatermarkText, "", 0, "C", false, 0, "")

	pdf.TransformEnd()
}

// addTableOfContents creates a professional table of contents.
// byCategory is pre-computed from Close to avoid redundant filtering.
// Page numbers are omitted because actual page breaks depend on content height,
// which isn't known until rendering. Section titles with dotted leaders are kept.
func (pw *PDFWriter) addTableOfContents(pdf *gofpdf.Fpdf, byCategory map[string][]*events.ResultEvent) {
	pdf.AddPage()

	// TOC Header
	pdf.SetFont("Helvetica", "B", 20)
	pdf.SetTextColor(30, 41, 59)
	pdf.CellFormat(0, 15, "Table of Contents", "", 1, "L", false, 0, "")
	pdf.Ln(5)

	// Build section titles matching actual render order.
	// Conditional sections (addTopBypasses, addCategoryBreakdown) return early
	// when there's no data, so they must not appear in the TOC either.
	entries := []string{
		"Executive Summary",
	}
	if pw.summary != nil && len(pw.summary.TopBypasses) > 0 {
		entries = append(entries, "Top Bypass Vulnerabilities")
	}
	if pw.summary != nil && len(pw.summary.Breakdown.ByCategory) > 0 {
		entries = append(entries, "Category Breakdown")
	}
	entries = append(entries, "OWASP Top 10 Coverage")
	if len(byCategory) == 0 {
		entries = append(entries, "Detailed Findings")
	}

	// Add per-category finding sections in sorted order.
	categories := make([]string, 0, len(byCategory))
	for cat := range byCategory {
		categories = append(categories, cat)
	}
	sort.Strings(categories)
	for _, cat := range categories {
		entries = append(entries, fmt.Sprintf("Findings: %s", strings.ToUpper(cat)))
	}
	entries = append(entries, "Appendix: Scan Configuration")
	entries = append(entries, "Appendix: Testing Methodology")

	pageW, _ := pdf.GetPageSize()
	contentW := pageW - 30 // Account for margins

	for _, title := range entries {
		pdf.SetFont("Helvetica", "", 12)
		pdf.SetTextColor(60, 60, 60)

		titleW := pdf.GetStringWidth(title)

		// Title
		pdf.CellFormat(titleW, 8, title, "", 0, "L", false, 0, "")

		// Dotted leader to right margin
		dotWidth := contentW - titleW - 10
		if dotWidth > 0 {
			dots := strings.Repeat(".", int(dotWidth/2))
			pdf.SetTextColor(180, 180, 180)
			pdf.CellFormat(dotWidth, 8, dots, "", 1, "C", false, 0, "")
		} else {
			pdf.Ln(8)
		}
	}
}

// addSeverityBarChart creates a horizontal bar chart for severity breakdown.
func (pw *PDFWriter) addSeverityBarChart(pdf *gofpdf.Fpdf, severityCounts map[string]int) {
	if len(severityCounts) == 0 {
		return
	}

	pdf.Ln(5)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Severity Distribution", "", 1, "L", false, 0, "")

	maxCount := 0
	for _, count := range severityCounts {
		if count > maxCount {
			maxCount = count
		}
	}
	if maxCount == 0 {
		maxCount = 1
	}

	barMaxWidth := 100.0
	severities := []string{"critical", "high", "medium", "low", "info"}

	for _, sev := range severities {
		count := severityCounts[sev]
		if count == 0 {
			continue
		}

		color := pdfSeverityColors[sev]
		if color == nil {
			color = []int{128, 128, 128}
		}
		barWidth := float64(count) / float64(maxCount) * barMaxWidth

		// Label
		pdf.SetFont("Helvetica", "", 10)
		pdf.SetTextColor(80, 80, 80)
		pdf.CellFormat(25, 7, cases.Title(language.English).String(sev), "", 0, "R", false, 0, "")

		// Bar
		pdf.SetFillColor(color[0], color[1], color[2])
		y := pdf.GetY()
		pdf.Rect(45, y+1, barWidth, 5, "F")

		// Count
		pdf.SetX(150)
		pdf.CellFormat(20, 7, fmt.Sprintf("%d", count), "", 1, "L", false, 0, "")
	}
}

// addRiskGauge creates a semi-circular gauge showing block rate.
func (pw *PDFWriter) addRiskGauge(pdf *gofpdf.Fpdf, blockRate float64) {
	// Clamp to valid range to avoid malformed arcs.
	if blockRate < 0 {
		blockRate = 0
	} else if blockRate > 100 {
		blockRate = 100
	}

	// Draw a semi-circular gauge
	cx, cy := 100.0, pdf.GetY()+40
	radius := 30.0

	// Background arc (gray semicircle)
	pdf.SetDrawColor(220, 220, 220)
	pdf.SetLineWidth(8)
	pdf.Arc(cx, cy, radius, radius, 0, 0, 180, "D")

	// Calculate angle for block rate
	angle := blockRate * 1.8 // 0-100% maps to 0-180 degrees

	// Foreground arc (colored by score)
	var r, g, b int
	if blockRate >= 80 {
		r, g, b = 22, 163, 74 // Green
	} else if blockRate >= 60 {
		r, g, b = 202, 138, 4 // Yellow
	} else {
		r, g, b = 220, 38, 38 // Red
	}

	pdf.SetDrawColor(r, g, b)
	if angle > 0 {
		pdf.Arc(cx, cy, radius, radius, 0, 180-angle, 180, "D")
	}

	pdf.SetLineWidth(0.2)

	// Center text
	pdf.SetFont("Helvetica", "B", 20)
	pdf.SetTextColor(r, g, b)
	pdf.SetXY(cx-25, cy-10)
	pdf.CellFormat(50, 20, fmt.Sprintf("%.0f%%", blockRate), "", 0, "C", false, 0, "")

	pdf.SetY(cy + 15)
}

// formatDuration formats seconds into a human-readable duration string.
func formatDuration(secs float64) string {
	if secs < 60 {
		return fmt.Sprintf("%.1fs", secs)
	}
	m := int(secs) / 60
	s := int(secs) % 60
	if m < 60 {
		return fmt.Sprintf("%dm %ds", m, s)
	}
	h := m / 60
	m = m % 60
	return fmt.Sprintf("%dh %dm %ds", h, m, s)
}

// addLatencyProfile renders latency percentile statistics in the executive summary.
func (pw *PDFWriter) addLatencyProfile(pdf *gofpdf.Fpdf) {
	if pw.summary == nil {
		return
	}
	lat := pw.summary.Latency
	// Only render if there's meaningful latency data.
	if lat.AvgMs == 0 && lat.P50Ms == 0 && lat.MaxMs == 0 {
		return
	}

	pdf.Ln(10)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Response Latency Profile", "", 1, "L", false, 0, "")

	pageW, _ := pdf.GetPageSize()

	metrics := []struct {
		label string
		value int64
		color []int
	}{
		{"Min", lat.MinMs, []int{22, 163, 74}},
		{"Avg", lat.AvgMs, []int{37, 99, 235}},
		{"P50", lat.P50Ms, []int{37, 99, 235}},
		{"P95", lat.P95Ms, []int{202, 138, 4}},
		{"P99", lat.P99Ms, []int{234, 88, 12}},
		{"Max", lat.MaxMs, []int{220, 38, 38}},
	}

	cellW := (pageW - 30) / float64(len(metrics))
	startY := pdf.GetY() + 3

	for i, m := range metrics {
		x := 15 + float64(i)*cellW

		pdf.SetFillColor(245, 245, 245)
		pdf.Rect(x, startY, cellW-2, 20, "F")

		pdf.SetFont("Helvetica", "B", 14)
		pdf.SetTextColor(m.color[0], m.color[1], m.color[2])
		pdf.SetXY(x, startY+1)
		pdf.CellFormat(cellW-2, 10, fmt.Sprintf("%d ms", m.value), "", 0, "C", false, 0, "")

		pdf.SetFont("Helvetica", "", 8)
		pdf.SetTextColor(100, 100, 100)
		pdf.SetXY(x, startY+11)
		pdf.CellFormat(cellW-2, 6, m.label, "", 0, "C", false, 0, "")
	}

	pdf.SetY(startY + 25)

	// Bar visualization: relative latency bars for percentiles.
	maxMs := lat.MaxMs
	if maxMs == 0 {
		maxMs = 1
	}
	barMaxW := pageW - 80

	bars := []struct {
		label string
		ms    int64
	}{
		{"P50", lat.P50Ms},
		{"P95", lat.P95Ms},
		{"P99", lat.P99Ms},
		{"Max", lat.MaxMs},
	}

	for _, b := range bars {
		barW := float64(b.ms) / float64(maxMs) * barMaxW
		if barW < 1 {
			barW = 1
		}

		pdf.SetFont("Helvetica", "", 9)
		pdf.SetTextColor(80, 80, 80)
		pdf.CellFormat(20, 6, b.label, "", 0, "R", false, 0, "")

		y := pdf.GetY()
		// Color gradient based on percentile
		var r, g, bv int
		ratio := float64(b.ms) / float64(maxMs)
		if ratio < 0.5 {
			r, g, bv = 22, 163, 74
		} else if ratio < 0.8 {
			r, g, bv = 202, 138, 4
		} else {
			r, g, bv = 220, 38, 38
		}
		pdf.SetFillColor(r, g, bv)
		pdf.Rect(40, y+1, barW, 4, "F")

		pdf.SetX(40 + barW + 3)
		pdf.SetFont("Helvetica", "", 8)
		pdf.CellFormat(0, 6, fmt.Sprintf("%d ms", b.ms), "", 1, "L", false, 0, "")
	}
}

// addTopBypasses renders the top bypass vulnerabilities as a prioritized table.
func (pw *PDFWriter) addTopBypasses(pdf *gofpdf.Fpdf) {
	if pw.summary == nil || len(pw.summary.TopBypasses) == 0 {
		return
	}

	pdf.AddPage()
	pw.addSectionHeader(pdf, "Top Bypass Vulnerabilities")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(80, 80, 80)
	pdf.MultiCell(0, 5, "The following bypasses represent the highest-priority vulnerabilities discovered during testing. "+
		"These should be addressed immediately as they indicate active gaps in WAF protection.", "", "L", false)
	pdf.Ln(5)

	pageW, _ := pdf.GetPageSize()
	tableW := pageW - 30

	// Table header
	pdf.SetFont("Helvetica", "B", 9)
	pdf.SetFillColor(30, 41, 59)
	pdf.SetTextColor(255, 255, 255)
	pdf.CellFormat(8, 7, "#", "1", 0, "C", true, 0, "")
	pdf.CellFormat(tableW*0.20, 7, "Test ID", "1", 0, "L", true, 0, "")
	pdf.CellFormat(tableW*0.15, 7, "Category", "1", 0, "C", true, 0, "")
	pdf.CellFormat(tableW*0.12, 7, "Severity", "1", 0, "C", true, 0, "")
	pdf.CellFormat(tableW*0.15, 7, "Encoding", "1", 0, "C", true, 0, "")
	pdf.CellFormat(0, 7, "Curl Command", "1", 1, "L", true, 0, "")

	// Table rows
	pdf.SetFont("Helvetica", "", 8)
	for i, bp := range pw.summary.TopBypasses {
		if i >= 15 {
			break // cap at 15 to avoid overflowing the page
		}

		// Alternating row colors
		if i%2 == 0 {
			pdf.SetFillColor(250, 250, 250)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}

		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(8, 6, fmt.Sprintf("%d", i+1), "1", 0, "C", true, 0, "")
		pdf.CellFormat(tableW*0.20, 6, truncateString(bp.ID, 25), "1", 0, "L", true, 0, "")
		pdf.CellFormat(tableW*0.15, 6, strings.ToUpper(bp.Category), "1", 0, "C", true, 0, "")

		// Severity with color
		sevColor := pdfSeverityColors[bp.Severity]
		if sevColor == nil {
			sevColor = []int{128, 128, 128}
		}
		pdf.SetTextColor(sevColor[0], sevColor[1], sevColor[2])
		pdf.SetFont("Helvetica", "B", 8)
		pdf.CellFormat(tableW*0.12, 6, strings.ToUpper(bp.Severity), "1", 0, "C", true, 0, "")
		pdf.SetFont("Helvetica", "", 8)
		pdf.SetTextColor(60, 60, 60)

		encoding := bp.Encoding
		if encoding == "" {
			encoding = "-"
		}
		pdf.CellFormat(tableW*0.15, 6, encoding, "1", 0, "C", true, 0, "")

		curl := bp.Curl
		if curl == "" {
			curl = "-"
		}
		pdf.CellFormat(0, 6, truncateString(curl, 50), "1", 1, "L", true, 0, "")
	}

	// Summary count
	pdf.Ln(3)
	pdf.SetFont("Helvetica", "I", 9)
	pdf.SetTextColor(100, 100, 100)
	total := len(pw.summary.TopBypasses)
	shown := total
	if shown > 15 {
		shown = 15
	}
	if total > shown {
		pdf.CellFormat(0, 6, fmt.Sprintf("Showing %d of %d total bypass vulnerabilities.", shown, total), "", 1, "L", false, 0, "")
	}
}

// addCategoryBreakdown renders block rate comparison across attack categories.
func (pw *PDFWriter) addCategoryBreakdown(pdf *gofpdf.Fpdf) {
	if pw.summary == nil || len(pw.summary.Breakdown.ByCategory) == 0 {
		return
	}

	pdf.AddPage()
	pw.addSectionHeader(pdf, "Category Breakdown")

	pageW, _ := pdf.GetPageSize()

	// Sort categories by block rate (worst first for risk prioritization).
	type catRow struct {
		name      string
		total     int
		bypasses  int
		blockRate float64
	}
	rows := make([]catRow, 0, len(pw.summary.Breakdown.ByCategory))
	for cat, stats := range pw.summary.Breakdown.ByCategory {
		rows = append(rows, catRow{
			name:      cat,
			total:     stats.Total,
			bypasses:  stats.Bypasses,
			blockRate: stats.BlockRate,
		})
	}
	sort.Slice(rows, func(i, j int) bool {
		return rows[i].blockRate < rows[j].blockRate
	})

	// Table
	pdf.SetFont("Helvetica", "B", 10)
	pdf.SetFillColor(30, 41, 59)
	pdf.SetTextColor(255, 255, 255)
	pdf.CellFormat(50, 8, "Category", "1", 0, "L", true, 0, "")
	pdf.CellFormat(30, 8, "Tests", "1", 0, "C", true, 0, "")
	pdf.CellFormat(30, 8, "Bypasses", "1", 0, "C", true, 0, "")
	pdf.CellFormat(35, 8, "Block Rate", "1", 0, "C", true, 0, "")
	pdf.CellFormat(0, 8, "Risk", "1", 1, "C", true, 0, "")

	pdf.SetFont("Helvetica", "", 10)
	for i, row := range rows {
		if i%2 == 0 {
			pdf.SetFillColor(250, 250, 250)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}

		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(50, 7, strings.ToUpper(row.name), "1", 0, "L", true, 0, "")
		pdf.CellFormat(30, 7, fmt.Sprintf("%d", row.total), "1", 0, "C", true, 0, "")

		if row.bypasses > 0 {
			pdf.SetTextColor(220, 38, 38)
		}
		pdf.CellFormat(30, 7, fmt.Sprintf("%d", row.bypasses), "1", 0, "C", true, 0, "")
		pdf.SetTextColor(60, 60, 60)

		// Block rate with color
		var brColor []int
		if row.blockRate >= 90 {
			brColor = []int{22, 163, 74}
		} else if row.blockRate >= 70 {
			brColor = []int{202, 138, 4}
		} else {
			brColor = []int{220, 38, 38}
		}
		pdf.SetTextColor(brColor[0], brColor[1], brColor[2])
		pdf.SetFont("Helvetica", "B", 10)
		pdf.CellFormat(35, 7, fmt.Sprintf("%.1f%%", row.blockRate), "1", 0, "C", true, 0, "")
		pdf.SetFont("Helvetica", "", 10)

		// Risk label
		risk := "LOW"
		riskColor := []int{22, 163, 74}
		if row.blockRate < 70 {
			risk = "HIGH"
			riskColor = []int{220, 38, 38}
		} else if row.blockRate < 90 {
			risk = "MEDIUM"
			riskColor = []int{202, 138, 4}
		}
		pdf.SetTextColor(riskColor[0], riskColor[1], riskColor[2])
		pdf.SetFont("Helvetica", "B", 10)
		pdf.CellFormat(0, 7, risk, "1", 1, "C", true, 0, "")
		pdf.SetFont("Helvetica", "", 10)
	}

	// Horizontal bar chart for block rates.
	pdf.Ln(8)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Block Rate by Category", "", 1, "L", false, 0, "")

	barMaxW := pageW - 90
	for _, row := range rows {
		barW := row.blockRate / 100.0 * barMaxW
		if barW < 1 && row.total > 0 {
			barW = 1
		}

		pdf.SetFont("Helvetica", "", 9)
		pdf.SetTextColor(80, 80, 80)
		pdf.CellFormat(35, 7, strings.ToUpper(row.name), "", 0, "R", false, 0, "")

		y := pdf.GetY()
		var r, g, b int
		if row.blockRate >= 90 {
			r, g, b = 22, 163, 74
		} else if row.blockRate >= 70 {
			r, g, b = 202, 138, 4
		} else {
			r, g, b = 220, 38, 38
		}
		pdf.SetFillColor(r, g, b)
		pdf.Rect(40, y+1, barW, 5, "F")

		pdf.SetX(40 + barMaxW + 3)
		pdf.SetFont("Helvetica", "", 8)
		pdf.CellFormat(0, 7, fmt.Sprintf("%.1f%%", row.blockRate), "", 1, "L", false, 0, "")
	}

	// Encoding breakdown below the chart if data exists.
	pw.addEncodingBreakdown(pdf)
}

// addEncodingBreakdown renders which payload encodings bypassed the WAF.
func (pw *PDFWriter) addEncodingBreakdown(pdf *gofpdf.Fpdf) {
	if pw.summary == nil || len(pw.summary.Breakdown.ByEncoding) == 0 {
		return
	}

	pdf.Ln(8)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(0, 10, "Encoding Effectiveness", "", 1, "L", false, 0, "")

	type encRow struct {
		name      string
		total     int
		bypasses  int
		blockRate float64
	}
	rows := make([]encRow, 0, len(pw.summary.Breakdown.ByEncoding))
	for enc, stats := range pw.summary.Breakdown.ByEncoding {
		rows = append(rows, encRow{
			name:      enc,
			total:     stats.Total,
			bypasses:  stats.Bypasses,
			blockRate: stats.BlockRate,
		})
	}
	sort.Slice(rows, func(i, j int) bool {
		return rows[i].blockRate < rows[j].blockRate
	})

	pdf.SetFont("Helvetica", "B", 9)
	pdf.SetFillColor(240, 240, 240)
	pdf.SetTextColor(60, 60, 60)
	pdf.CellFormat(50, 7, "Encoding", "1", 0, "L", true, 0, "")
	pdf.CellFormat(30, 7, "Tests", "1", 0, "C", true, 0, "")
	pdf.CellFormat(30, 7, "Bypasses", "1", 0, "C", true, 0, "")
	pdf.CellFormat(35, 7, "Block Rate", "1", 1, "C", true, 0, "")

	pdf.SetFont("Helvetica", "", 9)
	for _, row := range rows {
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(50, 6, row.name, "1", 0, "L", false, 0, "")
		pdf.CellFormat(30, 6, fmt.Sprintf("%d", row.total), "1", 0, "C", false, 0, "")

		if row.bypasses > 0 {
			pdf.SetTextColor(220, 38, 38)
		}
		pdf.CellFormat(30, 6, fmt.Sprintf("%d", row.bypasses), "1", 0, "C", false, 0, "")
		pdf.SetTextColor(60, 60, 60)

		pdf.CellFormat(35, 6, fmt.Sprintf("%.1f%%", row.blockRate), "1", 1, "C", false, 0, "")
	}
}

// addScanConfiguration renders the scan configuration as an appendix.
func (pw *PDFWriter) addScanConfiguration(pdf *gofpdf.Fpdf) {
	pdf.AddPage()
	pw.addSectionHeader(pdf, "Appendix: Scan Configuration")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(80, 80, 80)
	pdf.MultiCell(0, 5, "The following parameters were used for this scan. "+
		"Reproducing results requires the same configuration.", "", "L", false)
	pdf.Ln(5)

	// Collect config rows from StartEvent and SummaryEvent.
	type cfgRow struct {
		label, value string
	}
	var rows []cfgRow

	if pw.summary != nil {
		rows = append(rows, cfgRow{"Target URL", pw.summary.Target.URL})
		if pw.summary.Target.WAFDetected != "" {
			rows = append(rows, cfgRow{"WAF Detected", pw.summary.Target.WAFDetected})
		}
		if pw.summary.Target.WAFConfidence > 0 {
			rows = append(rows, cfgRow{"WAF Confidence", fmt.Sprintf("%.0f%%", pw.summary.Target.WAFConfidence*100)})
		}
		rows = append(rows, cfgRow{"Total Tests", fmt.Sprintf("%d", pw.summary.Totals.Tests)})
		if pw.summary.Timing.DurationSec > 0 {
			rows = append(rows, cfgRow{"Duration", formatDuration(pw.summary.Timing.DurationSec)})
		}
		if pw.summary.Timing.RequestsPerSec > 0 {
			rows = append(rows, cfgRow{"Throughput", fmt.Sprintf("%.1f req/s", pw.summary.Timing.RequestsPerSec)})
		}
		rows = append(rows, cfgRow{"Exit Code", fmt.Sprintf("%d", pw.summary.ExitCode)})
		if pw.summary.ExitReason != "" {
			rows = append(rows, cfgRow{"Exit Reason", pw.summary.ExitReason})
		}
		rows = append(rows, cfgRow{"Version", pw.summary.Version})
	}

	if pw.start != nil {
		if pw.start.Config.Concurrency > 0 {
			rows = append(rows, cfgRow{"Concurrency", fmt.Sprintf("%d", pw.start.Config.Concurrency)})
		}
		if pw.start.Config.Timeout > 0 {
			rows = append(rows, cfgRow{"Timeout", fmt.Sprintf("%ds", pw.start.Config.Timeout)})
		}
		if pw.start.Config.ThrottleMs > 0 {
			rows = append(rows, cfgRow{"Throttle", fmt.Sprintf("%d ms", pw.start.Config.ThrottleMs)})
		}
		if len(pw.start.Config.Categories) > 0 {
			rows = append(rows, cfgRow{"Categories", strings.Join(pw.start.Config.Categories, ", ")})
		}
		if len(pw.start.Config.Encodings) > 0 {
			rows = append(rows, cfgRow{"Encodings", strings.Join(pw.start.Config.Encodings, ", ")})
		}
		if len(pw.start.Config.Tampers) > 0 {
			rows = append(rows, cfgRow{"Tampers", strings.Join(pw.start.Config.Tampers, ", ")})
		}
		if pw.start.Config.Severity != "" {
			rows = append(rows, cfgRow{"Min Severity", pw.start.Config.Severity})
		}
		// Only render boolean config fields when they're explicitly true.
		// EmitStart callers don't always populate the full ScanConfig,
		// so false could mean "not set" rather than "intentionally disabled".
		if pw.start.Config.FollowRedirects {
			rows = append(rows, cfgRow{"Follow Redirects", "true"})
		}
		if pw.start.Config.VerifySSL {
			rows = append(rows, cfgRow{"Verify SSL", "true"})
		}
		if pw.start.Config.Proxy != "" {
			rows = append(rows, cfgRow{"Proxy", pw.start.Config.Proxy})
		}
		if pw.start.Config.ReplayProxy != "" {
			rows = append(rows, cfgRow{"Replay Proxy", pw.start.Config.ReplayProxy})
		}
		if pw.start.Config.SNI != "" {
			rows = append(rows, cfgRow{"SNI", pw.start.Config.SNI})
		}
	}

	if len(rows) == 0 {
		pdf.SetFont("Helvetica", "I", 10)
		pdf.SetTextColor(128, 128, 128)
		pdf.CellFormat(0, 8, "No scan configuration data available.", "", 1, "L", false, 0, "")
		return
	}

	// Render as two-column table.
	pdf.SetFont("Helvetica", "B", 10)
	pdf.SetFillColor(30, 41, 59)
	pdf.SetTextColor(255, 255, 255)
	pdf.CellFormat(55, 8, "Parameter", "1", 0, "L", true, 0, "")
	pdf.CellFormat(0, 8, "Value", "1", 1, "L", true, 0, "")

	pdf.SetFont("Helvetica", "", 10)
	for i, row := range rows {
		if i%2 == 0 {
			pdf.SetFillColor(250, 250, 250)
		} else {
			pdf.SetFillColor(255, 255, 255)
		}
		pdf.SetTextColor(80, 80, 80)
		pdf.SetFont("Helvetica", "B", 9)
		pdf.CellFormat(55, 7, row.label, "1", 0, "L", true, 0, "")
		pdf.SetFont("Helvetica", "", 9)
		pdf.SetTextColor(60, 60, 60)
		pdf.CellFormat(0, 7, truncateString(row.value, 80), "1", 1, "L", true, 0, "")
	}
}

// addMethodologyAppendix adds an appendix explaining testing methodology.
func (pw *PDFWriter) addMethodologyAppendix(pdf *gofpdf.Fpdf) {
	pdf.AddPage()
	pw.addSectionHeader(pdf, "Appendix: Testing Methodology")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(60, 60, 60)

	methodology := `WAFtester tests Web Application Firewalls across multiple attack categories using the following methodology:

1. ATTACK SIMULATION
   - Sends known attack payloads (SQL injection, XSS, etc.)
   - Tests against OWASP Top 10 categories
   - Uses evasion techniques to bypass signatures

2. RESPONSE ANALYSIS
   - Analyzes HTTP response codes
   - Detects blocking pages and error responses
   - Measures response timing for fingerprinting

3. EFFECTIVENESS SCORING
   - Calculates block rate (blocked / total tests)
   - Assigns letter grade based on coverage
   - Identifies gaps in WAF protection

4. SEVERITY CLASSIFICATION
   - Critical: Exploitable with high impact
   - High: Significant security risk
   - Medium: Moderate security concern
   - Low: Minor security issue
   - Info: Informational finding`

	pdf.MultiCell(0, 5, methodology, "", "L", false)

	// Add additional info
	pdf.Ln(10)
	pdf.SetFont("Helvetica", "B", 12)
	pdf.SetTextColor(30, 41, 59)
	pdf.CellFormat(0, 10, "Grading Scale", "", 1, "L", false, 0, "")

	pdf.SetFont("Helvetica", "", 10)
	pdf.SetTextColor(60, 60, 60)

	grades := `A+ (97-100%): Exceptional - Almost all attacks blocked
A  (93-96%):  Excellent - Very strong WAF protection
A- (90-92%):  Very Good - Strong protection with minor gaps
B+ (87-89%):  Good - Solid protection, some improvements needed
B  (83-86%):  Above Average - Moderate protection
B- (80-82%):  Satisfactory - Basic protection in place
C+ (77-79%):  Fair - Noticeable gaps in coverage
C  (73-76%):  Passing - Significant improvements needed
C- (70-72%):  Marginal - Many attacks getting through
D  (60-69%):  Poor - Weak WAF configuration
F  (<60%):    Failing - Critical security gaps`

	pdf.MultiCell(0, 5, grades, "", "L", false)
}
