package finding

import (
	"encoding/json"
	"testing"
	"time"
)

func TestVulnerability_JSONRoundtrip(t *testing.T) {
	t.Parallel()

	original := Vulnerability{
		URL:          "https://example.com/search",
		Parameter:    "q",
		Method:       "GET",
		Severity:     High,
		Description:  "SQL injection in search",
		Evidence:     "syntax error at position 42",
		Remediation:  "Use parameterized queries",
		Payload:      "' OR 1=1--",
		ResponseTime: 150 * time.Millisecond,
		CVSS:         7.5,
		Confidence:   0.95,
		ConfirmedBy:  2,
	}

	data, err := json.Marshal(original)
	if err != nil {
		t.Fatalf("Marshal: %v", err)
	}

	var decoded Vulnerability
	if err := json.Unmarshal(data, &decoded); err != nil {
		t.Fatalf("Unmarshal: %v", err)
	}

	if decoded.URL != original.URL {
		t.Errorf("URL = %q, want %q", decoded.URL, original.URL)
	}
	if decoded.Severity != original.Severity {
		t.Errorf("Severity = %q, want %q", decoded.Severity, original.Severity)
	}
	if decoded.CVSS != original.CVSS {
		t.Errorf("CVSS = %f, want %f", decoded.CVSS, original.CVSS)
	}
	if decoded.ConfirmedBy != original.ConfirmedBy {
		t.Errorf("ConfirmedBy = %d, want %d", decoded.ConfirmedBy, original.ConfirmedBy)
	}
	if decoded.Confidence != original.Confidence {
		t.Errorf("Confidence = %f, want %f", decoded.Confidence, original.Confidence)
	}
}

func TestVulnerability_JSONOmitEmpty(t *testing.T) {
	t.Parallel()

	v := Vulnerability{
		URL:      "https://example.com",
		Severity: Medium,
	}
	data, err := json.Marshal(v)
	if err != nil {
		t.Fatalf("Marshal: %v", err)
	}

	var m map[string]any
	if err := json.Unmarshal(data, &m); err != nil {
		t.Fatalf("Unmarshal: %v", err)
	}

	// Zero-value fields should be omitted
	for _, field := range []string{
		"parameter", "method", "description",
		"remediation", "payload",
	} {
		if _, ok := m[field]; ok {
			t.Errorf("field %q should be omitted when empty", field)
		}
	}

	// Required fields must always be present
	for _, field := range []string{"url", "severity"} {
		if _, ok := m[field]; !ok {
			t.Errorf("field %q must always be present", field)
		}
	}
}

func TestVulnerability_EmbeddingPattern(t *testing.T) {
	t.Parallel()

	// Demonstrates the embedding pattern for attack packages
	type SQLiVuln struct {
		Vulnerability
		DBMS          string `json:"dbms,omitempty"`
		InjectionType string `json:"injection_type"`
	}

	v := SQLiVuln{
		Vulnerability: Vulnerability{
			URL:      "https://example.com",
			Severity: Critical,
			Evidence: "MySQL syntax error",
		},
		DBMS:          "MySQL",
		InjectionType: "error-based",
	}

	data, err := json.Marshal(v)
	if err != nil {
		t.Fatalf("Marshal: %v", err)
	}

	var m map[string]any
	if err := json.Unmarshal(data, &m); err != nil {
		t.Fatalf("Unmarshal: %v", err)
	}

	// Base fields at top level (flat JSON)
	if m["severity"] != "critical" {
		t.Errorf("severity = %v, want %q", m["severity"], "critical")
	}
	if m["evidence"] != "MySQL syntax error" {
		t.Errorf("evidence = %v", m["evidence"])
	}

	// Extension fields also at top level
	if m["dbms"] != "MySQL" {
		t.Errorf("dbms = %v, want %q", m["dbms"], "MySQL")
	}
	if m["injection_type"] != "error-based" {
		t.Errorf("injection_type = %v", m["injection_type"])
	}
}

func TestVulnerability_ZeroValue(t *testing.T) {
	t.Parallel()

	var v Vulnerability
	data, err := json.Marshal(v)
	if err != nil {
		t.Fatalf("Marshal zero value: %v", err)
	}

	var m map[string]any
	if err := json.Unmarshal(data, &m); err != nil {
		t.Fatalf("Unmarshal: %v", err)
	}

	// url and severity always present (not omitempty)
	if _, ok := m["url"]; !ok {
		t.Error("url must be present even when empty")
	}
	if _, ok := m["severity"]; !ok {
		t.Error("severity must be present even when empty")
	}
}
