package exploit

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/waftester/waftester/pkg/finding"
)

func TestVulnTypes(t *testing.T) {
	types := []VulnType{
		VulnSQLi, VulnXSS, VulnLFI, VulnRCE, VulnSSRF,
		VulnXXE, VulnSSTI, VulnAuthBypass, VulnIDOR,
		VulnOpenRedirect, VulnInfoLeak, VulnFileUpload,
	}

	if len(types) != 12 {
		t.Errorf("Expected 12 vuln types, got %d", len(types))
	}

	// Check string values
	if string(VulnSQLi) != "sqli" {
		t.Error("VulnSQLi should be 'sqli'")
	}
	if string(VulnRCE) != "rce" {
		t.Error("VulnRCE should be 'rce'")
	}
}

func TestSeverityLevels(t *testing.T) {
	severities := []finding.Severity{
		finding.Critical, finding.High, finding.Medium,
		finding.Low, finding.Info,
	}

	if len(severities) != 5 {
		t.Errorf("Expected 5 severity levels, got %d", len(severities))
	}

	// Test ordering
	if severityOrder(finding.Critical) <= severityOrder(finding.High) {
		t.Error("Critical should be higher than High")
	}
	if severityOrder(finding.High) <= severityOrder(finding.Medium) {
		t.Error("High should be higher than Medium")
	}
}

func TestNewChainBuilder(t *testing.T) {
	builder := NewChainBuilder()
	if builder == nil {
		t.Fatal("NewChainBuilder returned nil")
	}

	// Should have default rules loaded
	rules := builder.GetRules()
	if len(rules) == 0 {
		t.Error("Expected default rules to be loaded")
	}

	// Should have at least 10 default rules
	if len(rules) < 10 {
		t.Errorf("Expected at least 10 default rules, got %d", len(rules))
	}
}

func TestChainBuilder_AddVulnerability(t *testing.T) {
	builder := NewChainBuilder()

	vuln := &Vulnerability{
		ID:           "vuln-1",
		Type:         VulnSQLi,
		Severity:     finding.High,
		Target:       "https://example.com",
		Endpoint:     "/api/users",
		Parameter:    "id",
		Confidence:   0.9,
		DiscoveredAt: time.Now(),
	}

	builder.AddVulnerability(vuln)

	vulns := builder.GetVulnerabilities()
	if len(vulns) != 1 {
		t.Errorf("Expected 1 vulnerability, got %d", len(vulns))
	}
	if vulns[0].ID != "vuln-1" {
		t.Error("Vulnerability ID mismatch")
	}
}

func TestChainBuilder_AddVulnerabilities(t *testing.T) {
	builder := NewChainBuilder()

	vulns := []*Vulnerability{
		{ID: "v1", Type: VulnSQLi, Target: "https://a.com", Confidence: 0.8},
		{ID: "v2", Type: VulnXSS, Target: "https://b.com", Confidence: 0.7},
		{ID: "v3", Type: VulnLFI, Target: "https://c.com", Confidence: 0.9},
	}

	builder.AddVulnerabilities(vulns)

	result := builder.GetVulnerabilities()
	if len(result) != 3 {
		t.Errorf("Expected 3 vulnerabilities, got %d", len(result))
	}
}

func TestChainBuilder_Build_EmptyVulns(t *testing.T) {
	builder := NewChainBuilder()

	chains, err := builder.Build(context.Background())
	if err != nil {
		t.Errorf("Build should not error on empty vulns: %v", err)
	}
	if len(chains) != 0 {
		t.Errorf("Expected 0 chains, got %d", len(chains))
	}
}

func TestChainBuilder_Build_SingleVuln(t *testing.T) {
	builder := NewChainBuilder()

	// Single RCE should create a direct chain
	builder.AddVulnerability(&Vulnerability{
		ID:         "rce-1",
		Type:       VulnRCE,
		Severity:   finding.Critical,
		Target:     "https://example.com",
		Endpoint:   "/shell",
		Confidence: 0.95,
	})

	chains, err := builder.Build(context.Background())
	if err != nil {
		t.Fatalf("Build failed: %v", err)
	}

	// Should have at least one direct RCE chain
	if len(chains) == 0 {
		t.Error("Expected at least 1 chain for direct RCE")
	}

	// Find the direct chain
	var found bool
	for _, chain := range chains {
		if chain.Goal == "rce" && len(chain.Steps) == 1 {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected to find a direct RCE chain")
	}
}

func TestChainBuilder_Build_ChainableVulns(t *testing.T) {
	builder := NewChainBuilder()

	// SSRF + RCE should chain together
	builder.AddVulnerabilities([]*Vulnerability{
		{
			ID:         "ssrf-1",
			Type:       VulnSSRF,
			Severity:   finding.High,
			Target:     "https://example.com",
			Endpoint:   "/fetch",
			Confidence: 0.85,
		},
		{
			ID:         "rce-1",
			Type:       VulnRCE,
			Severity:   finding.Critical,
			Target:     "https://example.com",
			Endpoint:   "/internal",
			Confidence: 0.90,
		},
	})

	chains, err := builder.Build(context.Background())
	if err != nil {
		t.Fatalf("Build failed: %v", err)
	}

	// Should find SSRF->RCE chain
	var foundChain *ExploitChain
	for _, chain := range chains {
		if chain.Name == "SSRF to RCE" {
			foundChain = chain
			break
		}
	}

	if foundChain == nil {
		t.Fatal("Expected to find SSRF to RCE chain")
	}

	if len(foundChain.Steps) != 2 {
		t.Errorf("Expected 2 steps, got %d", len(foundChain.Steps))
	}
}

func TestChainBuilder_Build_SQLiAuthBypass(t *testing.T) {
	builder := NewChainBuilder()

	builder.AddVulnerabilities([]*Vulnerability{
		{
			ID:         "sqli-1",
			Type:       VulnSQLi,
			Severity:   finding.High,
			Target:     "https://example.com",
			Endpoint:   "/login", // Auth context
			Confidence: 0.9,
		},
		{
			ID:         "auth-1",
			Type:       VulnAuthBypass,
			Severity:   finding.High,
			Target:     "https://example.com",
			Endpoint:   "/admin",
			Confidence: 0.8,
		},
	})

	chains, err := builder.Build(context.Background())
	if err != nil {
		t.Fatalf("Build failed: %v", err)
	}

	// Should find SQLi->AuthBypass chain
	var found bool
	for _, chain := range chains {
		if chain.Name == "SQLi to Auth Bypass" {
			found = true
			if chain.Goal != "auth-bypass" {
				t.Error("Chain goal should be auth-bypass")
			}
			break
		}
	}

	if !found {
		t.Error("Expected to find SQLi to Auth Bypass chain")
	}
}

func TestChainBuilder_GetChainsByGoal(t *testing.T) {
	builder := NewChainBuilder()

	builder.AddVulnerabilities([]*Vulnerability{
		{ID: "ssrf-1", Type: VulnSSRF, Target: "https://a.com", Confidence: 0.9},
		{ID: "rce-1", Type: VulnRCE, Target: "https://a.com", Confidence: 0.9},
		{ID: "sqli-1", Type: VulnSQLi, Target: "https://b.com", Endpoint: "/login", Confidence: 0.9},
		{ID: "auth-1", Type: VulnAuthBypass, Target: "https://b.com", Confidence: 0.9},
	})

	builder.Build(context.Background())

	rceChains := builder.GetChainsByGoal("rce")
	authChains := builder.GetChainsByGoal("auth-bypass")

	if len(rceChains) == 0 {
		t.Error("Expected at least 1 RCE goal chain")
	}
	if len(authChains) == 0 {
		t.Error("Expected at least 1 auth-bypass goal chain")
	}
}

func TestChainBuilder_GetChainsBySeverity(t *testing.T) {
	builder := NewChainBuilder()

	builder.AddVulnerabilities([]*Vulnerability{
		{ID: "low-1", Type: VulnInfoLeak, Target: "https://a.com", Severity: finding.Low, Confidence: 0.9},
		{ID: "rce-1", Type: VulnRCE, Target: "https://b.com", Severity: finding.Critical, Confidence: 0.9},
	})

	builder.Build(context.Background())

	criticalChains := builder.GetChainsBySeverity(finding.Critical)
	allChains := builder.GetChainsBySeverity(finding.Info)

	// Critical chains should be subset of all
	if len(criticalChains) > len(allChains) {
		t.Error("Critical chains should be <= all chains")
	}
}

func TestChainBuilder_AddRule(t *testing.T) {
	builder := NewChainBuilder()
	initialCount := len(builder.GetRules())

	builder.AddRule(ChainRule{
		Name:        "Custom Rule",
		Description: "Test custom rule",
		From:        []VulnType{VulnXSS},
		To:          []VulnType{VulnIDOR},
		Condition:   "any",
		Priority:    5,
		ResultGoal:  "custom",
	})

	if len(builder.GetRules()) != initialCount+1 {
		t.Error("Rule should be added")
	}
}

func TestChainBuilder_Clear(t *testing.T) {
	builder := NewChainBuilder()
	builder.AddVulnerability(&Vulnerability{ID: "v1"})
	builder.Build(context.Background())

	builder.Clear()

	if len(builder.GetVulnerabilities()) != 0 {
		t.Error("Vulnerabilities should be cleared")
	}
	if len(builder.GetChains()) != 0 {
		t.Error("Chains should be cleared")
	}
}

func TestNewChainExecutor(t *testing.T) {
	exec := NewChainExecutor(true, 30*time.Second)
	if exec == nil {
		t.Fatal("NewChainExecutor returned nil")
	}
	if !exec.dryRun {
		t.Error("dryRun should be true")
	}
	if exec.timeout != 30*time.Second {
		t.Error("timeout should be 30s")
	}
}

func TestChainExecutor_Execute_DryRun(t *testing.T) {
	exec := NewChainExecutor(true, 5*time.Second)

	chain := &ExploitChain{
		ID:     "test-chain",
		Name:   "Test Chain",
		Target: "https://example.com",
		Steps: []*ChainStep{
			{Order: 1, Name: "Step 1", Vuln: &Vulnerability{ID: "v1"}},
			{Order: 2, Name: "Step 2", Vuln: &Vulnerability{ID: "v2"}},
		},
		Goal:     "test",
		Severity: finding.High,
	}

	err := exec.Execute(context.Background(), chain)
	if err != nil {
		t.Errorf("Execute failed: %v", err)
	}

	if !chain.Verified {
		t.Error("Chain should be verified after successful execution")
	}

	for i, step := range chain.Steps {
		if !step.Executed {
			t.Errorf("Step %d should be executed", i+1)
		}
		if !step.Success {
			t.Errorf("Step %d should be successful", i+1)
		}
	}
}

func TestChainExecutor_Execute_WithCallback(t *testing.T) {
	exec := NewChainExecutor(true, 5*time.Second)

	var callbacks int
	exec.SetStepCallback(func(step *ChainStep) {
		callbacks++
	})

	chain := &ExploitChain{
		ID:     "cb-chain",
		Name:   "Callback Chain",
		Target: "https://example.com",
		Steps: []*ChainStep{
			{Order: 1, Name: "Step 1"},
			{Order: 2, Name: "Step 2"},
			{Order: 3, Name: "Step 3"},
		},
	}

	exec.Execute(context.Background(), chain)

	if callbacks != 3 {
		t.Errorf("Expected 3 callbacks, got %d", callbacks)
	}
}

func TestChainExecutor_Execute_Timeout(t *testing.T) {
	exec := NewChainExecutor(true, 1*time.Nanosecond) // Very short timeout

	chain := &ExploitChain{
		ID:   "timeout-chain",
		Name: "Timeout Chain",
		Steps: []*ChainStep{
			{Order: 1, Name: "Step 1"},
		},
	}

	// May or may not timeout depending on timing
	_ = exec.Execute(context.Background(), chain)
}

func TestChainExecutor_Execute_PassesOutput(t *testing.T) {
	exec := NewChainExecutor(true, 5*time.Second)

	chain := &ExploitChain{
		ID:   "output-chain",
		Name: "Output Chain",
		Steps: []*ChainStep{
			{Order: 1, Name: "Step 1", Output: map[string]string{"token": "abc123"}},
			{Order: 2, Name: "Step 2"},
		},
	}

	exec.Execute(context.Background(), chain)

	// Step 2 should have received output from step 1
	if chain.Steps[1].Input == nil {
		t.Error("Step 2 should have input from step 1")
	}
	if chain.Steps[1].Input["token"] != "abc123" {
		t.Error("Token should be passed to step 2")
	}
}

func TestNewChainAnalyzer(t *testing.T) {
	analyzer := NewChainAnalyzer()
	if analyzer == nil {
		t.Fatal("NewChainAnalyzer returned nil")
	}
}

func TestChainAnalyzer_Analyze_VerifiedChain(t *testing.T) {
	analyzer := NewChainAnalyzer()

	chain := &ExploitChain{
		ID:         "verified-chain",
		Name:       "Verified Chain",
		Target:     "https://example.com",
		Goal:       "rce",
		Confidence: 0.9,
		Steps: []*ChainStep{
			{
				Order: 1,
				Name:  "Step 1",
				Vuln: &Vulnerability{
					ID:       "v1",
					Verified: true,
				},
			},
		},
	}

	analysis := analyzer.Analyze(chain)
	if analysis == nil {
		t.Fatal("Analysis returned nil")
	}

	if analysis.ChainID != "verified-chain" {
		t.Error("ChainID mismatch")
	}

	// High feasibility for verified vuln
	if analysis.Feasibility < 0.5 {
		t.Errorf("Expected higher feasibility, got %f", analysis.Feasibility)
	}

	// Should have RCE mitigations
	if len(analysis.Mitigations) == 0 {
		t.Error("Expected mitigations for RCE goal")
	}
}

func TestChainAnalyzer_Analyze_UnverifiedVuln(t *testing.T) {
	analyzer := NewChainAnalyzer()

	chain := &ExploitChain{
		ID:         "unverified-chain",
		Confidence: 0.8,
		Steps: []*ChainStep{
			{Vuln: &Vulnerability{Verified: false}},
		},
	}

	analysis := analyzer.Analyze(chain)

	// Should have reduced feasibility
	if analysis.Feasibility >= 0.8 {
		t.Error("Feasibility should be reduced for unverified vuln")
	}

	// Should have risk noted
	var hasRisk bool
	for _, risk := range analysis.Risks {
		if risk != "" {
			hasRisk = true
			break
		}
	}
	if !hasRisk {
		t.Error("Expected risk for unverified vulnerability")
	}
}

func TestChainAnalyzer_Analyze_LongChain(t *testing.T) {
	analyzer := NewChainAnalyzer()

	chain := &ExploitChain{
		ID:         "long-chain",
		Confidence: 0.9,
		Steps: []*ChainStep{
			{Vuln: &Vulnerability{Verified: true}},
			{Vuln: &Vulnerability{Verified: true}},
			{Vuln: &Vulnerability{Verified: true}},
			{Vuln: &Vulnerability{Verified: true}}, // 4 steps
		},
	}

	analysis := analyzer.Analyze(chain)

	// Should note increased failure probability
	var hasLongChainRisk bool
	for _, risk := range analysis.Risks {
		if risk == "Long chain increases failure probability" {
			hasLongChainRisk = true
			break
		}
	}
	if !hasLongChainRisk {
		t.Error("Expected risk for long chain")
	}
}

func TestChainAnalyzer_Analyze_DataExfil(t *testing.T) {
	analyzer := NewChainAnalyzer()

	chain := &ExploitChain{
		ID:         "data-chain",
		Goal:       "data-exfil",
		Confidence: 0.8,
		Steps:      []*ChainStep{{Vuln: &Vulnerability{Verified: true}}},
	}

	analysis := analyzer.Analyze(chain)

	// Should have data-exfil mitigations
	var hasDataMitigation bool
	for _, m := range analysis.Mitigations {
		if m == "Parameterized queries" || m == "Data encryption" {
			hasDataMitigation = true
			break
		}
	}
	if !hasDataMitigation {
		t.Error("Expected data-exfil mitigations")
	}
}

func TestChainAnalyzer_Analyze_AuthBypass(t *testing.T) {
	analyzer := NewChainAnalyzer()

	chain := &ExploitChain{
		ID:         "auth-chain",
		Goal:       "auth-bypass",
		Confidence: 0.7,
		Steps:      []*ChainStep{{Vuln: &Vulnerability{Verified: true}}},
	}

	analysis := analyzer.Analyze(chain)

	// Should have auth mitigations
	var hasAuthMitigation bool
	for _, m := range analysis.Mitigations {
		if m == "Multi-factor authentication" || m == "Rate limiting" {
			hasAuthMitigation = true
			break
		}
	}
	if !hasAuthMitigation {
		t.Error("Expected auth-bypass mitigations")
	}
}

func TestExtractTarget(t *testing.T) {
	tests := []struct {
		url      string
		expected string
	}{
		{"https://example.com/path", "example.com"},
		{"http://api.test.com:8080/", "api.test.com:8080"},
		{"invalid-url", ""}, // Invalid URL returns empty host
	}

	for _, tc := range tests {
		result := extractTarget(tc.url)
		if result != tc.expected {
			t.Errorf("extractTarget(%s) = %s, want %s", tc.url, result, tc.expected)
		}
	}
}

func TestContainsVulnType(t *testing.T) {
	types := []VulnType{VulnSQLi, VulnXSS, VulnRCE}

	if !containsVulnType(types, VulnSQLi) {
		t.Error("Should contain SQLi")
	}
	if containsVulnType(types, VulnLFI) {
		t.Error("Should not contain LFI")
	}
}

func TestGetAction(t *testing.T) {
	tests := []struct {
		vulnType VulnType
		expected string
	}{
		{VulnRCE, "execute"},
		{VulnSQLi, "read"},
		{VulnLFI, "read"},
		{VulnFileUpload, "write"},
		{VulnAuthBypass, "escalate"},
		{VulnIDOR, "escalate"},
		{VulnXSS, "exploit"},
	}

	for _, tc := range tests {
		result := getAction(tc.vulnType)
		if result != tc.expected {
			t.Errorf("getAction(%s) = %s, want %s", tc.vulnType, result, tc.expected)
		}
	}
}

func TestSeverityOrder(t *testing.T) {
	tests := []struct {
		severity finding.Severity
		expected int
	}{
		{finding.Critical, 5},
		{finding.High, 4},
		{finding.Medium, 3},
		{finding.Low, 2},
		{finding.Info, 1},
		{finding.Severity("unknown"), 0},
	}

	for _, tc := range tests {
		result := severityOrder(tc.severity)
		if result != tc.expected {
			t.Errorf("severityOrder(%s) = %d, want %d", tc.severity, result, tc.expected)
		}
	}
}

func TestChainBuilder_ConcurrentAccess(t *testing.T) {
	builder := NewChainBuilder()

	// Concurrent adds
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func(id int) {
			builder.AddVulnerability(&Vulnerability{
				ID:   fmt.Sprintf("v-%d", id),
				Type: VulnSQLi,
			})
			done <- true
		}(i)
	}

	for i := 0; i < 10; i++ {
		<-done
	}

	vulns := builder.GetVulnerabilities()
	if len(vulns) != 10 {
		t.Errorf("Expected 10 vulnerabilities, got %d", len(vulns))
	}
}

func TestChainBuilder_XXEToSSRF(t *testing.T) {
	builder := NewChainBuilder()

	builder.AddVulnerabilities([]*Vulnerability{
		{ID: "xxe-1", Type: VulnXXE, Target: "https://a.com", Confidence: 0.8},
		{ID: "ssrf-1", Type: VulnSSRF, Target: "https://a.com", Confidence: 0.9},
	})

	chains, _ := builder.Build(context.Background())

	var found bool
	for _, chain := range chains {
		if chain.Name == "XXE to SSRF" {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected XXE to SSRF chain")
	}
}

func TestChainBuilder_SSTIToRCE(t *testing.T) {
	builder := NewChainBuilder()

	builder.AddVulnerabilities([]*Vulnerability{
		{ID: "ssti-1", Type: VulnSSTI, Target: "https://a.com", Confidence: 0.85},
		{ID: "rce-1", Type: VulnRCE, Target: "https://a.com", Confidence: 0.9},
	})

	chains, _ := builder.Build(context.Background())

	var found bool
	for _, chain := range chains {
		if chain.Name == "SSTI to RCE" {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected SSTI to RCE chain")
	}
}

func TestChainBuilder_InfoLeakCredentials(t *testing.T) {
	builder := NewChainBuilder()

	builder.AddVulnerabilities([]*Vulnerability{
		{
			ID:         "leak-1",
			Type:       VulnInfoLeak,
			Target:     "https://a.com",
			Evidence:   "Found password: admin123",
			Confidence: 0.95,
		},
		{ID: "auth-1", Type: VulnAuthBypass, Target: "https://a.com", Confidence: 0.9},
	})

	chains, _ := builder.Build(context.Background())

	var found bool
	for _, chain := range chains {
		if chain.Name == "Info Leak to Auth Bypass" {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected Info Leak to Auth Bypass chain when credentials are leaked")
	}
}

func TestChainBuilder_MultipleTargets(t *testing.T) {
	builder := NewChainBuilder()

	// Vulnerabilities on different targets should NOT chain
	builder.AddVulnerabilities([]*Vulnerability{
		{ID: "ssrf-1", Type: VulnSSRF, Target: "https://a.com", Confidence: 0.9},
		{ID: "rce-1", Type: VulnRCE, Target: "https://b.com", Confidence: 0.9}, // Different target
	})

	chains, _ := builder.Build(context.Background())

	// Should only have direct chains, no cross-target chains
	for _, chain := range chains {
		if chain.Name == "SSRF to RCE" {
			t.Error("Should not chain vulns from different targets")
		}
	}
}

func TestVulnerability_Struct(t *testing.T) {
	vuln := &Vulnerability{
		ID:           "test-vuln",
		Type:         VulnSQLi,
		Severity:     finding.High,
		Target:       "https://example.com",
		Endpoint:     "/api/data",
		Parameter:    "id",
		Payload:      "' OR 1=1--",
		Evidence:     "SQL syntax error",
		Confidence:   0.85,
		Verified:     true,
		Metadata:     map[string]string{"db": "mysql"},
		DiscoveredAt: time.Now(),
	}

	if vuln.ID != "test-vuln" {
		t.Error("ID mismatch")
	}
	if vuln.Parameter != "id" {
		t.Error("Parameter mismatch")
	}
	if vuln.Metadata["db"] != "mysql" {
		t.Error("Metadata mismatch")
	}
}

func TestChainStep_Struct(t *testing.T) {
	step := &ChainStep{
		Order:       1,
		Name:        "Test Step",
		Description: "A test step",
		Vuln:        &Vulnerability{ID: "v1"},
		Action:      "execute",
		Input:       map[string]string{"key": "value"},
		Output:      map[string]string{"result": "success"},
		Executed:    true,
		Success:     true,
		Result:      "Command executed",
		Duration:    100 * time.Millisecond,
	}

	if step.Order != 1 {
		t.Error("Order mismatch")
	}
	if step.Input["key"] != "value" {
		t.Error("Input mismatch")
	}
}

func TestExploitChain_Struct(t *testing.T) {
	now := time.Now()
	chain := &ExploitChain{
		ID:          "chain-1",
		Name:        "Test Chain",
		Description: "A test chain",
		Target:      "https://example.com",
		Steps:       []*ChainStep{{Order: 1}},
		Goal:        "rce",
		Severity:    finding.Critical,
		Confidence:  0.9,
		Verified:    true,
		CreatedAt:   now,
		ExecutedAt:  &now,
		Duration:    1 * time.Second,
	}

	if chain.ID != "chain-1" {
		t.Error("ID mismatch")
	}
	if chain.ExecutedAt == nil {
		t.Error("ExecutedAt should be set")
	}
}

func TestChainRule_Struct(t *testing.T) {
	rule := ChainRule{
		Name:        "Test Rule",
		Description: "A test rule",
		From:        []VulnType{VulnSSRF},
		To:          []VulnType{VulnRCE},
		Condition:   "internal_access",
		Priority:    10,
		ResultGoal:  "rce",
	}

	if rule.Name != "Test Rule" {
		t.Error("Name mismatch")
	}
	if rule.Priority != 10 {
		t.Error("Priority mismatch")
	}
}

func TestChainAnalysis_Struct(t *testing.T) {
	analysis := &ChainAnalysis{
		ChainID:     "chain-1",
		Feasibility: 0.75,
		Risks:       []string{"Risk 1", "Risk 2"},
		Mitigations: []string{"Mit 1", "Mit 2"},
	}

	if analysis.ChainID != "chain-1" {
		t.Error("ChainID mismatch")
	}
	if len(analysis.Risks) != 2 {
		t.Error("Risks count mismatch")
	}
}
