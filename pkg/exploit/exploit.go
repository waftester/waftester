// Package exploit provides automatic exploit chain generation and execution
package exploit

import (
	"context"
	"fmt"
	"net/url"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/waftester/waftester/pkg/finding"
)

// VulnType represents a vulnerability type
type VulnType string

const (
	VulnSQLi         VulnType = "sqli"
	VulnXSS          VulnType = "xss"
	VulnLFI          VulnType = "lfi"
	VulnRCE          VulnType = "rce"
	VulnSSRF         VulnType = "ssrf"
	VulnXXE          VulnType = "xxe"
	VulnSSTI         VulnType = "ssti"
	VulnAuthBypass   VulnType = "auth-bypass"
	VulnIDOR         VulnType = "idor"
	VulnOpenRedirect VulnType = "open-redirect"
	VulnInfoLeak     VulnType = "info-leak"
	VulnFileUpload   VulnType = "file-upload"
)

// Vulnerability represents a discovered vulnerability
type Vulnerability struct {
	ID           string            `json:"id"`
	Type         VulnType          `json:"type"`
	Severity     finding.Severity  `json:"severity"`
	Target       string            `json:"target"`
	Endpoint     string            `json:"endpoint"`
	Parameter    string            `json:"parameter,omitempty"`
	Payload      string            `json:"payload,omitempty"`
	Evidence     string            `json:"evidence,omitempty"`
	Confidence   float64           `json:"confidence"` // 0.0-1.0
	Verified     bool              `json:"verified"`
	Metadata     map[string]string `json:"metadata,omitempty"`
	DiscoveredAt time.Time         `json:"discovered_at"`
}

// ChainStep represents a step in an exploit chain
type ChainStep struct {
	Order       int               `json:"order"`
	Name        string            `json:"name"`
	Description string            `json:"description"`
	Vuln        *Vulnerability    `json:"vulnerability"`
	Action      string            `json:"action"`           // read, write, execute, escalate
	Input       map[string]string `json:"input,omitempty"`  // Data from previous step
	Output      map[string]string `json:"output,omitempty"` // Data for next step
	Executed    bool              `json:"executed"`
	Success     bool              `json:"success"`
	Result      string            `json:"result,omitempty"`
	Duration    time.Duration     `json:"duration,omitempty"`
}

// ExploitChain represents a sequence of exploits
type ExploitChain struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Target      string           `json:"target"`
	Steps       []*ChainStep     `json:"steps"`
	Goal        string           `json:"goal"` // rce, data-exfil, privilege-escalation, etc.
	Severity    finding.Severity `json:"severity"`
	Confidence  float64          `json:"confidence"`
	Verified    bool             `json:"verified"`
	CreatedAt   time.Time        `json:"created_at"`
	ExecutedAt  *time.Time       `json:"executed_at,omitempty"`
	Duration    time.Duration    `json:"duration,omitempty"`
}

// ChainBuilder builds exploit chains from vulnerabilities
type ChainBuilder struct {
	rules  []ChainRule
	vulns  []*Vulnerability
	chains []*ExploitChain
	mu     sync.RWMutex
}

// ChainRule defines how vulnerabilities can be chained
type ChainRule struct {
	Name        string     `json:"name"`
	Description string     `json:"description"`
	From        []VulnType `json:"from"`        // Starting vulnerability types
	To          []VulnType `json:"to"`          // Next vulnerability types
	Condition   string     `json:"condition"`   // e.g., "same_endpoint", "same_target"
	Priority    int        `json:"priority"`    // Higher = prefer this chain
	ResultGoal  string     `json:"result_goal"` // What this chain achieves
}

// NewChainBuilder creates a new chain builder
func NewChainBuilder() *ChainBuilder {
	builder := &ChainBuilder{
		vulns:  make([]*Vulnerability, 0),
		chains: make([]*ExploitChain, 0),
	}
	builder.loadDefaultRules()
	return builder
}

func (b *ChainBuilder) loadDefaultRules() {
	b.rules = []ChainRule{
		{
			Name:        "SSRF to RCE",
			Description: "Use SSRF to reach internal services and achieve RCE",
			From:        []VulnType{VulnSSRF},
			To:          []VulnType{VulnRCE},
			Condition:   "internal_access",
			Priority:    10,
			ResultGoal:  "rce",
		},
		{
			Name:        "SQLi to Auth Bypass",
			Description: "Use SQL injection to bypass authentication",
			From:        []VulnType{VulnSQLi},
			To:          []VulnType{VulnAuthBypass},
			Condition:   "auth_context",
			Priority:    9,
			ResultGoal:  "auth-bypass",
		},
		{
			Name:        "LFI to RCE",
			Description: "Use LFI with log poisoning or inclusion to achieve RCE",
			From:        []VulnType{VulnLFI},
			To:          []VulnType{VulnRCE},
			Condition:   "file_write",
			Priority:    10,
			ResultGoal:  "rce",
		},
		{
			Name:        "XXE to SSRF",
			Description: "Use XXE to perform internal requests",
			From:        []VulnType{VulnXXE},
			To:          []VulnType{VulnSSRF},
			Condition:   "any",
			Priority:    7,
			ResultGoal:  "internal-access",
		},
		{
			Name:        "SSTI to RCE",
			Description: "Server-side template injection leading to code execution",
			From:        []VulnType{VulnSSTI},
			To:          []VulnType{VulnRCE},
			Condition:   "code_context",
			Priority:    10,
			ResultGoal:  "rce",
		},
		{
			Name:        "File Upload to RCE",
			Description: "Upload malicious file for code execution",
			From:        []VulnType{VulnFileUpload},
			To:          []VulnType{VulnRCE},
			Condition:   "executable_upload",
			Priority:    10,
			ResultGoal:  "rce",
		},
		{
			Name:        "Auth Bypass to IDOR",
			Description: "Bypass auth to access other users' resources",
			From:        []VulnType{VulnAuthBypass},
			To:          []VulnType{VulnIDOR},
			Condition:   "user_context",
			Priority:    6,
			ResultGoal:  "data-access",
		},
		{
			Name:        "Open Redirect to XSS",
			Description: "Use open redirect for XSS phishing",
			From:        []VulnType{VulnOpenRedirect},
			To:          []VulnType{VulnXSS},
			Condition:   "same_target",
			Priority:    5,
			ResultGoal:  "session-hijack",
		},
		{
			Name:        "Info Leak to Auth Bypass",
			Description: "Use leaked credentials or tokens for auth bypass",
			From:        []VulnType{VulnInfoLeak},
			To:          []VulnType{VulnAuthBypass},
			Condition:   "credential_leak",
			Priority:    8,
			ResultGoal:  "auth-bypass",
		},
		{
			Name:        "SQLi to Data Exfil",
			Description: "Extract sensitive data via SQL injection",
			From:        []VulnType{VulnSQLi},
			To:          []VulnType{VulnInfoLeak},
			Condition:   "data_context",
			Priority:    7,
			ResultGoal:  "data-exfil",
		},
	}
}

// AddVulnerability adds a vulnerability to consider for chaining
func (b *ChainBuilder) AddVulnerability(vuln *Vulnerability) {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.vulns = append(b.vulns, vuln)
}

// AddVulnerabilities adds multiple vulnerabilities
func (b *ChainBuilder) AddVulnerabilities(vulns []*Vulnerability) {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.vulns = append(b.vulns, vulns...)
}

// GetVulnerabilities returns all vulnerabilities
func (b *ChainBuilder) GetVulnerabilities() []*Vulnerability {
	b.mu.RLock()
	defer b.mu.RUnlock()
	result := make([]*Vulnerability, len(b.vulns))
	copy(result, b.vulns)
	return result
}

// Build generates exploit chains from vulnerabilities
func (b *ChainBuilder) Build(ctx context.Context) ([]*ExploitChain, error) {
	b.mu.Lock()
	defer b.mu.Unlock()

	b.chains = make([]*ExploitChain, 0)

	// Group vulnerabilities by target
	byTarget := make(map[string][]*Vulnerability)
	for _, v := range b.vulns {
		target := extractTarget(v.Target)
		byTarget[target] = append(byTarget[target], v)
	}

	// For each target, find possible chains
	for target, vulns := range byTarget {
		chains := b.findChains(target, vulns)
		b.chains = append(b.chains, chains...)
	}

	// Sort by severity and confidence
	sort.Slice(b.chains, func(i, j int) bool {
		if b.chains[i].Severity != b.chains[j].Severity {
			return b.chains[i].Severity.Score() > b.chains[j].Severity.Score()
		}
		return b.chains[i].Confidence > b.chains[j].Confidence
	})

	return b.chains, nil
}

func (b *ChainBuilder) findChains(target string, vulns []*Vulnerability) []*ExploitChain {
	var chains []*ExploitChain

	// Check each rule
	for _, rule := range b.rules {
		// Find starting vulnerabilities
		for _, vuln := range vulns {
			if !containsVulnType(rule.From, vuln.Type) {
				continue
			}

			// Find connecting vulnerabilities
			for _, nextVuln := range vulns {
				if vuln.ID == nextVuln.ID {
					continue
				}
				if !containsVulnType(rule.To, nextVuln.Type) {
					continue
				}

				// Check condition
				if !b.checkCondition(rule.Condition, vuln, nextVuln) {
					continue
				}

				// Create chain
				chain := b.createChain(target, rule, vuln, nextVuln)
				chains = append(chains, chain)
			}
		}
	}

	// Also create single-step chains for high-impact vulns
	for _, vuln := range vulns {
		if vuln.Type == VulnRCE || vuln.Type == VulnSQLi {
			chain := &ExploitChain{
				ID:          fmt.Sprintf("chain-%s-direct", vuln.ID),
				Name:        fmt.Sprintf("Direct %s", strings.ToUpper(string(vuln.Type))),
				Description: fmt.Sprintf("Direct exploitation of %s vulnerability", vuln.Type),
				Target:      target,
				Steps: []*ChainStep{
					{
						Order:       1,
						Name:        fmt.Sprintf("Exploit %s", vuln.Type),
						Description: vuln.Evidence,
						Vuln:        vuln,
						Action:      "execute",
					},
				},
				Goal:       string(vuln.Type),
				Severity:   vuln.Severity,
				Confidence: vuln.Confidence,
				CreatedAt:  time.Now(),
			}
			chains = append(chains, chain)
		}
	}

	return chains
}

func (b *ChainBuilder) checkCondition(condition string, from, to *Vulnerability) bool {
	switch condition {
	case "any":
		return true
	case "same_target":
		return extractTarget(from.Target) == extractTarget(to.Target)
	case "same_endpoint":
		return from.Endpoint == to.Endpoint
	case "auth_context":
		return strings.Contains(strings.ToLower(from.Endpoint), "login") ||
			strings.Contains(strings.ToLower(from.Endpoint), "auth")
	case "internal_access":
		return true // Assume SSRF can reach internal services
	case "file_write":
		return true // Assume LFI might have write capability
	case "code_context":
		return true // Assume SSTI is in code context
	case "executable_upload":
		return true // Assume file upload allows executables
	case "user_context":
		return true // Assume user context exists
	case "credential_leak":
		return strings.Contains(strings.ToLower(from.Evidence), "password") ||
			strings.Contains(strings.ToLower(from.Evidence), "token") ||
			strings.Contains(strings.ToLower(from.Evidence), "api_key")
	case "data_context":
		return true
	default:
		return false
	}
}

func (b *ChainBuilder) createChain(target string, rule ChainRule, from, to *Vulnerability) *ExploitChain {
	chainID := fmt.Sprintf("chain-%s-%s", from.ID, to.ID)

	steps := []*ChainStep{
		{
			Order:       1,
			Name:        fmt.Sprintf("Exploit %s", from.Type),
			Description: fmt.Sprintf("Initial access via %s at %s", from.Type, from.Endpoint),
			Vuln:        from,
			Action:      getAction(from.Type),
			Output:      map[string]string{"access": "initial"},
		},
		{
			Order:       2,
			Name:        fmt.Sprintf("Chain to %s", to.Type),
			Description: fmt.Sprintf("Leverage access for %s at %s", to.Type, to.Endpoint),
			Vuln:        to,
			Action:      getAction(to.Type),
			Input:       map[string]string{"access": "initial"},
			Output:      map[string]string{"result": rule.ResultGoal},
		},
	}

	// Calculate chain severity (highest of all vulns)
	severity := from.Severity
	if to.Severity.Score() > severity.Score() {
		severity = to.Severity
	}

	// Confidence is product of individual confidences
	confidence := from.Confidence * to.Confidence

	return &ExploitChain{
		ID:          chainID,
		Name:        rule.Name,
		Description: rule.Description,
		Target:      target,
		Steps:       steps,
		Goal:        rule.ResultGoal,
		Severity:    severity,
		Confidence:  confidence,
		CreatedAt:   time.Now(),
	}
}

func getAction(vulnType VulnType) string {
	switch vulnType {
	case VulnRCE:
		return "execute"
	case VulnSQLi, VulnLFI, VulnInfoLeak:
		return "read"
	case VulnFileUpload:
		return "write"
	case VulnAuthBypass, VulnIDOR:
		return "escalate"
	default:
		return "exploit"
	}
}

// GetChains returns all built chains
func (b *ChainBuilder) GetChains() []*ExploitChain {
	b.mu.RLock()
	defer b.mu.RUnlock()
	result := make([]*ExploitChain, len(b.chains))
	copy(result, b.chains)
	return result
}

// GetChainsByGoal returns chains with a specific goal
func (b *ChainBuilder) GetChainsByGoal(goal string) []*ExploitChain {
	b.mu.RLock()
	defer b.mu.RUnlock()

	var result []*ExploitChain
	for _, chain := range b.chains {
		if chain.Goal == goal {
			result = append(result, chain)
		}
	}
	return result
}

// GetChainsBySeverity returns chains with minimum severity
func (b *ChainBuilder) GetChainsBySeverity(minSeverity finding.Severity) []*ExploitChain {
	b.mu.RLock()
	defer b.mu.RUnlock()

	minOrder := minSeverity.Score()
	var result []*ExploitChain
	for _, chain := range b.chains {
		if chain.Severity.Score() >= minOrder {
			result = append(result, chain)
		}
	}
	return result
}

// ChainExecutor executes exploit chains
type ChainExecutor struct {
	dryRun     bool
	timeout    time.Duration
	onStepDone func(*ChainStep)
}

// NewChainExecutor creates a new executor
func NewChainExecutor(dryRun bool, timeout time.Duration) *ChainExecutor {
	return &ChainExecutor{
		dryRun:  dryRun,
		timeout: timeout,
	}
}

// SetStepCallback sets a callback for step completion
func (e *ChainExecutor) SetStepCallback(fn func(*ChainStep)) {
	e.onStepDone = fn
}

// Execute runs an exploit chain
func (e *ChainExecutor) Execute(ctx context.Context, chain *ExploitChain) error {
	ctx, cancel := context.WithTimeout(ctx, e.timeout)
	defer cancel()

	startTime := time.Now()
	chain.ExecutedAt = &startTime

	for i, step := range chain.Steps {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		stepStart := time.Now()

		if e.dryRun {
			// Simulate execution
			step.Executed = true
			step.Success = true
			step.Result = fmt.Sprintf("[DRY RUN] Would execute: %s", step.Name)
		} else {
			// Real execution would go here
			step.Executed = true
			step.Success = true
			step.Result = fmt.Sprintf("Executed step %d: %s", i+1, step.Name)
		}

		step.Duration = time.Since(stepStart)

		if e.onStepDone != nil {
			e.onStepDone(step)
		}

		// Pass output to next step
		if i < len(chain.Steps)-1 && step.Output != nil {
			chain.Steps[i+1].Input = step.Output
		}

		if !step.Success {
			chain.Verified = false
			return fmt.Errorf("step %d failed: %s", i+1, step.Name)
		}
	}

	chain.Verified = true
	chain.Duration = time.Since(startTime)
	return nil
}

// ChainAnalyzer analyzes chains for feasibility
type ChainAnalyzer struct{}

// NewChainAnalyzer creates a new analyzer
func NewChainAnalyzer() *ChainAnalyzer {
	return &ChainAnalyzer{}
}

// Analyze evaluates chain feasibility
func (a *ChainAnalyzer) Analyze(chain *ExploitChain) *ChainAnalysis {
	analysis := &ChainAnalysis{
		ChainID:     chain.ID,
		Feasibility: 1.0,
		Risks:       make([]string, 0),
		Mitigations: make([]string, 0),
	}

	// Check step dependencies
	for i, step := range chain.Steps {
		if step.Vuln == nil {
			analysis.Feasibility *= 0.5
			analysis.Risks = append(analysis.Risks, fmt.Sprintf("Step %d missing vulnerability details", i+1))
		} else if !step.Vuln.Verified {
			analysis.Feasibility *= 0.7
			analysis.Risks = append(analysis.Risks, fmt.Sprintf("Step %d vulnerability not verified", i+1))
		}
	}

	// Adjust for chain length
	if len(chain.Steps) > 3 {
		analysis.Feasibility *= 0.8
		analysis.Risks = append(analysis.Risks, "Long chain increases failure probability")
	}

	// Add mitigations based on goal
	switch chain.Goal {
	case "rce":
		analysis.Mitigations = append(analysis.Mitigations,
			"Input validation and sanitization",
			"Disable dangerous functions",
			"Implement WAF rules")
	case "data-exfil":
		analysis.Mitigations = append(analysis.Mitigations,
			"Parameterized queries",
			"Data encryption",
			"Access logging")
	case "auth-bypass":
		analysis.Mitigations = append(analysis.Mitigations,
			"Multi-factor authentication",
			"Session management improvements",
			"Rate limiting")
	}

	analysis.Feasibility *= chain.Confidence

	return analysis
}

// ChainAnalysis represents analysis results
type ChainAnalysis struct {
	ChainID     string   `json:"chain_id"`
	Feasibility float64  `json:"feasibility"` // 0.0-1.0
	Risks       []string `json:"risks"`
	Mitigations []string `json:"mitigations"`
}

// Helper functions
func extractTarget(targetURL string) string {
	u, err := url.Parse(targetURL)
	if err != nil {
		return targetURL
	}
	return u.Host
}

func containsVulnType(types []VulnType, t VulnType) bool {
	for _, vt := range types {
		if vt == t {
			return true
		}
	}
	return false
}

// AddRule adds a custom chain rule
func (b *ChainBuilder) AddRule(rule ChainRule) {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.rules = append(b.rules, rule)
}

// GetRules returns all chain rules
func (b *ChainBuilder) GetRules() []ChainRule {
	b.mu.RLock()
	defer b.mu.RUnlock()
	result := make([]ChainRule, len(b.rules))
	copy(result, b.rules)
	return result
}

// Clear removes all vulnerabilities and chains
func (b *ChainBuilder) Clear() {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.vulns = make([]*Vulnerability, 0)
	b.chains = make([]*ExploitChain, 0)
}
