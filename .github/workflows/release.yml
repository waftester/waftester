name: Release

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types:
      - completed

permissions:
  contents: write

# Prevent parallel release runs - serialize by commit SHA
# First run wins, subsequent runs wait and can skip if release exists
concurrency:
  group: release-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
    # Only run if CI workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}
          persist-credentials: false

      - name: Get tag name if present
        id: get_tag
        run: |
          # Check if the commit has a tag â€” only tagged commits get released
          TAG=$(git describe --tags --exact-match "$HEAD_SHA" 2>/dev/null || echo "")
          if [ -n "$TAG" ]; then
            echo "tag=$TAG" >> $GITHUB_OUTPUT
            echo "is_tag=true" >> $GITHUB_OUTPUT
          else
            echo "is_tag=false" >> $GITHUB_OUTPUT
            echo "â­ï¸ No tag on commit $HEAD_SHA â€” skipping release"
          fi

      - name: Check if release already published
        if: steps.get_tag.outputs.is_tag == 'true'
        id: check_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          # Check if release exists AND has assets (meaning another run already published)
          ASSET_COUNT=$(gh release view "$TAG" --json assets -q '.assets | length' 2>/dev/null || echo "0")
          if [ "$ASSET_COUNT" -gt "0" ]; then
            # Assets exist â€” but the release may be stuck as a draft (e.g. tag was
            # deleted and re-created while GoReleaser was mid-run). Publish it if so.
            IS_DRAFT=$(gh release view "$TAG" --json isDraft -q '.isDraft' 2>/dev/null || echo "false")
            if [ "$IS_DRAFT" = "true" ]; then
              echo "âš ï¸ Release $TAG has $ASSET_COUNT assets but is still a draft â€” publishing now"
              gh release edit "$TAG" --draft=false
              echo "âœ… Draft release $TAG published"
            else
              echo "âœ… Release $TAG already published with $ASSET_COUNT assets"
            fi
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Release $TAG not yet published or has no assets - proceeding"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify tag is on main branch
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        run: |
          # Check if this commit exists on main branch
          if ! git branch -r --contains "$HEAD_SHA" | grep -q "origin/main"; then
            echo "::error::Tag must be created from main branch. This tag points to a commit not on main."
            echo "Tagged commit: $HEAD_SHA"
            echo "Branches containing this commit:"
            git branch -r --contains "$HEAD_SHA"
            exit 1
          fi
          
          echo "âœ… Tag verified: commit $HEAD_SHA is on main branch"

      - name: Set up Go
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version-file: go.mod
          cache: true

      - name: Preserve manual release notes
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        id: prev_notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          # Save any manually-written release notes before GoReleaser replaces them.
          # These may have been added via GitHub UI before CI ran.
          PREV_BODY=$(gh release view "$TAG" --json body -q '.body' 2>/dev/null || echo "")
          if [ -n "$PREV_BODY" ]; then
            echo "ðŸ“ Found existing release notes for $TAG â€” preserving"
            echo "$PREV_BODY" > /tmp/prev_notes.md
            echo "has_prev=true" >> $GITHUB_OUTPUT
          else
            echo "No existing release notes to preserve"
            echo "has_prev=false" >> $GITHUB_OUTPUT
          fi

      - name: Run GoReleaser (tagged release)
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        uses: goreleaser/goreleaser-action@e435ccd777264be153ace6237001ef4d979d3a7a # v6.4.0
        with:
          distribution: goreleaser
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_CURRENT_TAG: ${{ steps.get_tag.outputs.tag }}

      - name: Merge preserved notes into release
        if: steps.get_tag.outputs.is_tag == 'true' && steps.prev_notes.outputs.has_prev == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          # Append the previously-written manual notes below the GoReleaser output
          CURRENT_BODY=$(gh release view "$TAG" --json body -q '.body' 2>/dev/null || echo "")
          PREV_BODY=$(cat /tmp/prev_notes.md)
          MERGED=$(printf '%s\n\n---\n\n### Previous Release Notes\n\n%s' "$CURRENT_BODY" "$PREV_BODY")
          gh release edit "$TAG" --notes "$MERGED"
          echo "âœ… Merged preserved release notes into $TAG"
