name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: write

# Prevent parallel release runs - serialize by commit SHA
# First run wins, subsequent runs wait and can skip if release exists
concurrency:
  group: release-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
    # Only run if CI succeeded for a push event (not PRs).
    # Without this filter, fork PRs passing CI trigger Release (which skips
    # at the tag check, but wastes Actions minutes).
    if: >-
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'push'
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}
          persist-credentials: false

      - name: Get tag name if present
        id: get_tag
        run: |
          # Check if the commit has a tag ‚Äî only tagged commits get released
          TAG=$(git describe --tags --exact-match "$HEAD_SHA" 2>/dev/null || echo "")
          if [ -n "$TAG" ]; then
            echo "tag=$TAG" >> $GITHUB_OUTPUT
            echo "is_tag=true" >> $GITHUB_OUTPUT
          else
            echo "is_tag=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è No tag on commit $HEAD_SHA ‚Äî skipping release"
          fi

      - name: Check if release already published
        if: steps.get_tag.outputs.is_tag == 'true'
        id: check_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          # Check if release exists AND has assets (meaning another run already published)
          ASSET_COUNT=$(gh release view "$TAG" --json assets -q '.assets | length' 2>/dev/null || echo "0")
          if [ "$ASSET_COUNT" -gt "0" ]; then
            # Assets exist ‚Äî but the release may be stuck as a draft (e.g. tag was
            # deleted and re-created while GoReleaser was mid-run). Publish it if so.
            IS_DRAFT=$(gh release view "$TAG" --json isDraft -q '.isDraft' 2>/dev/null || echo "false")
            if [ "$IS_DRAFT" = "true" ]; then
              echo "‚ö†Ô∏è Release $TAG has $ASSET_COUNT assets but is still a draft ‚Äî publishing now"
              gh release edit "$TAG" --draft=false
              echo "‚úÖ Draft release $TAG published"
            else
              echo "‚úÖ Release $TAG already published with $ASSET_COUNT assets"
            fi
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Release $TAG not yet published or has no assets - proceeding"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify tag is on main branch
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        run: |
          # Check if this commit exists on main branch
          if ! git branch -r --contains "$HEAD_SHA" | grep -q "origin/main"; then
            echo "::error::Tag must be created from main branch. This tag points to a commit not on main."
            echo "Tagged commit: $HEAD_SHA"
            echo "Branches containing this commit:"
            git branch -r --contains "$HEAD_SHA"
            exit 1
          fi
          
          echo "‚úÖ Tag verified: commit $HEAD_SHA is on main branch"

      - name: Set up Go
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version-file: go.mod
          cache: true

      - name: Preserve manual release notes
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        id: prev_notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          # Save any manually-written release notes before GoReleaser replaces them.
          # These may have been added via GitHub UI before CI ran.
          PREV_BODY=$(gh release view "$TAG" --json body -q '.body' 2>/dev/null || echo "")
          if [ -n "$PREV_BODY" ]; then
            echo "üìù Found existing release notes for $TAG ‚Äî preserving"
            echo "$PREV_BODY" > /tmp/prev_notes.md
            echo "has_prev=true" >> $GITHUB_OUTPUT
          else
            echo "No existing release notes to preserve"
            echo "has_prev=false" >> $GITHUB_OUTPUT
          fi

      - name: Run GoReleaser (tagged release)
        if: steps.get_tag.outputs.is_tag == 'true' && steps.check_release.outputs.skip != 'true'
        uses: goreleaser/goreleaser-action@e435ccd777264be153ace6237001ef4d979d3a7a # v6.4.0
        with:
          distribution: goreleaser
          version: '~> v2'
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_CURRENT_TAG: ${{ steps.get_tag.outputs.tag }}

      - name: Merge preserved notes into release
        if: steps.get_tag.outputs.is_tag == 'true' && steps.prev_notes.outputs.has_prev == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          # Append the previously-written manual notes below the GoReleaser output
          CURRENT_BODY=$(gh release view "$TAG" --json body -q '.body' 2>/dev/null || echo "")
          PREV_BODY=$(cat /tmp/prev_notes.md)
          printf '%s\n\n---\n\n### Previous Release Notes\n\n%s' "$CURRENT_BODY" "$PREV_BODY" > /tmp/merged_notes.md
          gh release edit "$TAG" --notes-file /tmp/merged_notes.md
          echo "‚úÖ Merged preserved release notes into $TAG"

      # Notify waftester-action repo to auto-update Marketplace listing.
      # Requires ACTION_SYNC_TOKEN secret ‚Äî a fine-grained PAT with
      # Contents: write scope on waftester/waftester-action.
      - name: Notify waftester-action
        if: >-
          steps.get_tag.outputs.is_tag == 'true' &&
          steps.check_release.outputs.skip != 'true'
        env:
          ACTION_SYNC_TOKEN: ${{ secrets.ACTION_SYNC_TOKEN }}
          TAG: ${{ steps.get_tag.outputs.tag }}
        run: |
          if [ -z "$ACTION_SYNC_TOKEN" ]; then
            echo "‚è≠Ô∏è ACTION_SYNC_TOKEN not set ‚Äî skipping waftester-action notification"
            exit 0
          fi
          VERSION="${TAG#v}"
          echo "üì° Dispatching cli-release event to waftester-action (version: ${VERSION})"
          GITHUB_TOKEN="$ACTION_SYNC_TOKEN" gh api repos/waftester/waftester-action/dispatches \
            -f event_type="cli-release" \
            -f "client_payload[version]=${VERSION}" \
            -f "client_payload[tag]=${TAG}" \
            --silent
          echo "‚úÖ Dispatch sent"
