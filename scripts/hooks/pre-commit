#!/usr/bin/env bash
# Pre-commit hook: identity check, private file guard, and code quality gates.
# "Instructions are advisory. Verification is deterministic." (Anthropic)
# A git hook that runs these checks CANNOT be skipped (without --no-verify).

set -euo pipefail

# ============================================================================
# IDENTITY CHECK — BLOCK COMMITS WITH PERSONAL NAME/EMAIL
# ============================================================================
# The public repo must only have commits from the project identity.
# This catches cases where the local git config was reset or overridden.
ALLOWED_EMAIL="dev@waftester.com"

AUTHOR_NAME=$(git config user.name 2>/dev/null || echo "")
AUTHOR_EMAIL=$(git config user.email 2>/dev/null || echo "")

if [ "$AUTHOR_EMAIL" != "$ALLOWED_EMAIL" ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: Unauthorized identity detected in git config         ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "  Current:  $AUTHOR_NAME <$AUTHOR_EMAIL>"
    echo "  Expected: WAFtester <dev@waftester.com>"
    echo ""
    echo "Fix with:"
    echo "  git config user.name 'WAFtester'"
    echo "  git config user.email 'dev@waftester.com'"
    echo ""
    exit 1
fi

# ============================================================================
# PRIVATE PATHS — NEVER COMMIT THESE TO THE PUBLIC REPO
# ============================================================================
# Add new private paths here as patterns (matched against staged file paths).
# Patterns are matched using grep -E (extended regex).
PRIVATE_PATTERNS=(
    '^\\.github/agents/'
    '^\\.github/instructions/'
    '^\\.github/prompts/'
    '^\\.github/skills/'
    '^\\.github/workspace/'
    '^\\.github/copilot-instructions\\.md'
    '^\\.github/memory-seed\\.json'
    '^\\.claude/'
    '^\\.mcp\\.json'
    '^\\.vscode/'
    '^docs/plans/'
    '^docs/research/'
)

# Build combined regex
COMBINED_PATTERN=$(IFS='|'; echo "${PRIVATE_PATTERNS[*]}")

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null || true)

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

# Check for private files in staging area
VIOLATIONS=$(echo "$STAGED_FILES" | grep -E "$COMBINED_PATTERN" || true)

if [ -n "$VIOLATIONS" ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: Private files detected in commit                     ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "The following files must NOT be committed to the public repo:"
    echo ""
    echo "$VIOLATIONS" | while read -r file; do
        echo "  ✗ $file"
    done
    echo ""
    echo "These files should be in .gitignore. If you see this error,"
    echo "check that .gitignore has not been modified incorrectly."
    echo ""
    echo "To unstage these files:"
    echo "  git reset HEAD <file>"
    echo ""
    echo "To force commit (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi

# ============================================================================
# CODE QUALITY — BLOCK DEBUG ARTIFACTS
# ============================================================================
# Catch fmt.Println/fmt.Printf left in Go code (use slog instead).
# Add "// debug:keep" on the same line to suppress.
for file in $STAGED_FILES; do
    [ -f "$file" ] || continue
    case "$file" in
        *.go)
            if grep -n 'fmt\.Println\|fmt\.Printf' "$file" 2>/dev/null | grep -v '// debug:keep' | head -1 | grep -q .; then
                echo "BLOCKED: $file has debug statement (fmt.Print). Use slog or add // debug:keep" >&2
                exit 1
            fi
            ;;
    esac
done

# ============================================================================
# CODE QUALITY — BLOCK ORPHAN TODOs
# ============================================================================
# TODOs without issue references (#123) are noise that never gets fixed.
for file in $STAGED_FILES; do
    [ -f "$file" ] || continue
    case "$file" in
        *.go)
            if grep -n 'TODO\|FIXME\|HACK\|XXX' "$file" 2>/dev/null | grep -v '#[0-9]' | head -3 | grep -q .; then
                echo "BLOCKED: $file has TODO/FIXME without issue ref (e.g., TODO #123)" >&2
                exit 1
            fi
            ;;
    esac
done

# ============================================================================
# CODE QUALITY — GO VET ON STAGED PACKAGES
# ============================================================================
# Run go vet on packages that have staged .go files. Catches issues like
# malformed string literals and missing commas that go build/test may miss.
GO_STAGED=$(echo "$STAGED_FILES" | grep '\.go$' || true)
if [ -n "$GO_STAGED" ]; then
    # Extract unique package directories from staged Go files.
    VET_PKGS=$(echo "$GO_STAGED" | xargs -I{} dirname {} | sort -u | sed 's|^|./|')
    if [ -n "$VET_PKGS" ]; then
        echo "Running go vet on staged packages..."
        if ! go vet $VET_PKGS 2>&1; then
            echo ""
            echo "╔══════════════════════════════════════════════════════════════════╗"
            echo "║  BLOCKED: go vet found issues in staged Go files               ║"
            echo "╚══════════════════════════════════════════════════════════════════╝"
            echo ""
            echo "Fix the vet errors above before committing."
            echo ""
            exit 1
        fi
        echo "  ✓ go vet passed"
    fi
fi

# ============================================================================
# CODE QUALITY — BLOCK HARDCODED SECRETS
# ============================================================================
for file in $STAGED_FILES; do
    [ -f "$file" ] || continue
    case "$file" in
        *.env*|*.pem|*.key) continue ;; # Handled by .gitignore
    esac
    if grep -nP '(password|secret|api_key|token|private_key)\s*[:=]\s*["\x27][^"\x27]{8,}' "$file" 2>/dev/null | head -1 | grep -qi .; then
        echo "BLOCKED: $file may contain hardcoded secret" >&2
        exit 1
    fi
done
