#!/usr/bin/env bash
# Pre-push hook: catch issues that would fail CI before pushing.
# Runs go vet, structural tests (test/ module), validates Dockerfile COPY
# sources vs .dockerignore, checks version consistency, and blocks private
# plan files.

set -euo pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
ERRORS=0

# Capture stdin (pushed refs) — git provides this and it can only be read once
PUSH_REFS=$(cat)

# ============================================================================
# GO VET — catch vet issues locally before CI discovers them
# ============================================================================
echo "Running go vet..."
# Exclude iouring (intentional unsafe.Pointer for mmap'd kernel ring buffers)
PACKAGES=$(go list ./... | grep -v '/iouring$')
if ! go vet $PACKAGES 2>&1; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: go vet found issues                                  ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "Fix the vet errors above, then try pushing again."
    echo ""
    ERRORS=$((ERRORS + 1))
fi

# ============================================================================
# DOCKERFILE vs .DOCKERIGNORE — prevent Docker build failures
# ============================================================================
DOCKERFILE="$REPO_ROOT/Dockerfile"
DOCKERIGNORE="$REPO_ROOT/.dockerignore"

if [ -f "$DOCKERFILE" ] && [ -f "$DOCKERIGNORE" ]; then
    echo "Checking Dockerfile COPY sources vs .dockerignore..."

    # Extract COPY source paths, skip --from= (multi-stage copies)
    COPY_PATHS=$(grep -E '^\s*COPY\s' "$DOCKERFILE" | grep -v -- '--from=' \
        | sed -E 's/^\s*COPY\s+//' | awk '{print $1}' | sed 's|/$||')

    for path in $COPY_PATHS; do
        if grep -qE "^${path}/?$" "$DOCKERIGNORE" 2>/dev/null; then
            echo ""
            echo "  ✗ Dockerfile COPY source '$path' is excluded by .dockerignore"
            ERRORS=$((ERRORS + 1))
        fi
    done

    if [ $ERRORS -eq 0 ]; then
        echo "  ✓ All Dockerfile COPY sources available in build context"
    fi
fi

# ============================================================================
# DEFAULTS ENFORCEMENT — version consistency + no-hardcoded-values guards
# ============================================================================
# Runs ALL tests in pkg/defaults/ which includes:
#   - Version consistency (defaults.go, npm, docs, EXAMPLES.md)
#   - No-hardcoded checks (concurrency, retries, depth, redirects, etc.)
# Adding a new TestNoHardcoded* test automatically enforces it here.
echo "Running version consistency check..."
if ! go test -count=1 ./pkg/defaults/ > /dev/null 2>&1; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: defaults enforcement tests failed                    ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    # Re-run with verbose output to show exactly what failed
    go test -v -count=1 ./pkg/defaults/ 2>&1 | grep -E -- '--- FAIL|FAIL\s|found|expected|hardcoded|Hardcoded|npm|package.json|Document Version|Docker|INSTALLATION|Concurrency|MaxDepth|Retries|MaxRedirects|ContentType|UserAgent|ToolName|OWASP' || true
    echo ""
    echo "Common fixes:"
    echo "  Version mismatch — update all 7 mandatory files (use version-bump skill)"
    echo "  Hardcoded value  — use defaults.Concurrency*, defaults.Depth*, etc."
    echo ""
    ERRORS=$((ERRORS + 1))
else
    echo "  ✓ All version references consistent"
fi

# ============================================================================
# STRUCTURAL TESTS — catch banned patterns (direct prints, raw severity, etc.)
# ============================================================================
# The test/ directory is a separate Go module with structural enforcement tests.
# These scan pkg/ and cmd/ for banned patterns that go vet doesn't catch.
echo "Running structural tests..."
if ! (cd "$REPO_ROOT/test" && go test -count=1 . > /dev/null 2>&1); then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: structural tests failed                              ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    (cd "$REPO_ROOT/test" && go test -v -count=1 . 2>&1 | grep -E -- '--- FAIL|FAIL\s|found|direct print|raw severity|signal\.Notify|string\(rune' || true)
    echo ""
    echo "Common fixes:"
    echo "  Direct print — use slog or ui package instead of fmt.Print/log.Print"
    echo "  Raw severity — use finding.Critical, finding.High, etc."
    echo ""
    ERRORS=$((ERRORS + 1))
else
    echo "  ✓ All structural checks passed"
fi

# ============================================================================
# PRIVATE PLANS — never push docs/plans/ markdown files
# ============================================================================
echo "Checking for private plan files..."

PLAN_FOUND=0
while read -r local_ref local_sha remote_ref remote_sha; do
    # Skip empty lines or delete pushes
    [ -z "$local_sha" ] && continue
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # Determine files changed in the commits being pushed
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        # New branch — diff against merge-base with main
        merge_base=$(git merge-base "$local_sha" origin/main 2>/dev/null || echo "")
        if [ -z "$merge_base" ]; then
            # No merge-base (orphan branch or no origin/main) — check all commits
            PLAN_FILES=$(git log --diff-filter=ACMR --name-only --pretty=format: "$local_sha" 2>/dev/null | grep -E '^docs/plans/.*\.md$' | sort -u || true)
        else
            PLAN_FILES=$(git diff --name-only "${merge_base}..${local_sha}" 2>/dev/null | grep -E '^docs/plans/.*\.md$' || true)
        fi
    else
        PLAN_FILES=$(git diff --name-only "${remote_sha}..${local_sha}" 2>/dev/null | grep -E '^docs/plans/.*\.md$' || true)
    fi

    if [ -n "$PLAN_FILES" ]; then
        echo ""
        echo "╔══════════════════════════════════════════════════════════════════╗"
        echo "║  BLOCKED: Private plan files detected in push                  ║"
        echo "╚══════════════════════════════════════════════════════════════════╝"
        echo ""
        echo "  The following plan files must not be pushed:"
        echo "$PLAN_FILES" | sed 's/^/    ✗ /'
        echo ""
        echo "  These files are local-only (gitignored). If they appear in"
        echo "  commits, remove them with: git rm --cached <file>"
        echo ""
        PLAN_FOUND=1
        break
    fi
done < <(echo "$PUSH_REFS")

if [ $PLAN_FOUND -eq 1 ]; then
    ERRORS=$((ERRORS + 1))
else
    echo "  ✓ No private plan files in push"
fi

# ============================================================================
# RESULT
# ============================================================================
if [ $ERRORS -gt 0 ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  PUSH BLOCKED: $ERRORS issue(s) found                              ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "To force push (NOT RECOMMENDED):"
    echo "  git push --no-verify"
    echo ""
    exit 1
fi

echo "✓ Pre-push checks passed"
