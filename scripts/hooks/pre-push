#!/usr/bin/env bash
# Pre-push hook: catch issues that would fail CI before pushing.
# Runs go vet, validates Dockerfile COPY sources vs .dockerignore,
# checks version consistency, and blocks private plan files.

set -euo pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
ERRORS=0

# Capture stdin (pushed refs) — git provides this and it can only be read once
PUSH_REFS=$(cat)

# ============================================================================
# GO VET — catch vet issues locally before CI discovers them
# ============================================================================
echo "Running go vet..."
# Exclude iouring (intentional unsafe.Pointer for mmap'd kernel ring buffers)
PACKAGES=$(go list ./... | grep -v '/iouring$')
if ! go vet $PACKAGES 2>&1; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: go vet found issues                                  ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "Fix the vet errors above, then try pushing again."
    echo ""
    ERRORS=$((ERRORS + 1))
fi

# ============================================================================
# DOCKERFILE vs .DOCKERIGNORE — prevent Docker build failures
# ============================================================================
DOCKERFILE="$REPO_ROOT/Dockerfile"
DOCKERIGNORE="$REPO_ROOT/.dockerignore"

if [ -f "$DOCKERFILE" ] && [ -f "$DOCKERIGNORE" ]; then
    echo "Checking Dockerfile COPY sources vs .dockerignore..."

    # Extract COPY source paths, skip --from= (multi-stage copies)
    COPY_PATHS=$(grep -E '^\s*COPY\s' "$DOCKERFILE" | grep -v -- '--from=' \
        | sed -E 's/^\s*COPY\s+//' | awk '{print $1}' | sed 's|/$||')

    for path in $COPY_PATHS; do
        if grep -qE "^${path}/?$" "$DOCKERIGNORE" 2>/dev/null; then
            echo ""
            echo "  ✗ Dockerfile COPY source '$path' is excluded by .dockerignore"
            ERRORS=$((ERRORS + 1))
        fi
    done

    if [ $ERRORS -eq 0 ]; then
        echo "  ✓ All Dockerfile COPY sources available in build context"
    fi
fi

# ============================================================================
# VERSION CONSISTENCY — catch stale version references before CI does
# ============================================================================
echo "Running version consistency check..."
if ! go test -run TestVersionConsistency -count=1 ./pkg/defaults/ > /dev/null 2>&1; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: Version inconsistency detected                       ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    # Re-run with verbose output to show exactly what's wrong
    go test -v -run TestVersionConsistency -count=1 ./pkg/defaults/ 2>&1 | grep -E 'FAIL|found|expected|hardcoded' || true
    echo ""
    echo "After bumping defaults.Version, also update:"
    echo "  - SECURITY.md  (Current stable release)"
    echo "  - CHANGELOG.md (version header)"
    echo ""
    ERRORS=$((ERRORS + 1))
else
    echo "  ✓ All version references consistent"
fi

# ============================================================================
# PRIVATE PLANS — never push docs/plans/ markdown files
# ============================================================================
echo "Checking for private plan files..."

PLAN_FOUND=0
while read -r local_ref local_sha remote_ref remote_sha; do
    # Skip empty lines or delete pushes
    [ -z "$local_sha" ] && continue
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # For new branches, diff against the merge-base with main
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        merge_base=$(git merge-base "$local_sha" origin/main 2>/dev/null || echo "")
        if [ -z "$merge_base" ]; then
            range="$local_sha"
        else
            range="${merge_base}..${local_sha}"
        fi
    else
        range="${remote_sha}..${local_sha}"
    fi

    # Check for plan files in the commits being pushed
    PLAN_FILES=$(git diff --name-only "$range" 2>/dev/null | grep -E '^docs/plans/.*\.md$' || true)
    if [ -n "$PLAN_FILES" ]; then
        echo ""
        echo "╔══════════════════════════════════════════════════════════════════╗"
        echo "║  BLOCKED: Private plan files detected in push                  ║"
        echo "╚══════════════════════════════════════════════════════════════════╝"
        echo ""
        echo "  The following plan files must not be pushed:"
        echo "$PLAN_FILES" | sed 's/^/    ✗ /'
        echo ""
        echo "  These files are local-only (gitignored). If they appear in"
        echo "  commits, remove them with: git rm --cached <file>"
        echo ""
        PLAN_FOUND=1
        break
    fi
done < <(echo "$PUSH_REFS")

if [ $PLAN_FOUND -eq 1 ]; then
    ERRORS=$((ERRORS + 1))
else
    echo "  ✓ No private plan files in push"
fi

# ============================================================================
# RESULT
# ============================================================================
if [ $ERRORS -gt 0 ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  PUSH BLOCKED: $ERRORS issue(s) found                              ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "To force push (NOT RECOMMENDED):"
    echo "  git push --no-verify"
    echo ""
    exit 1
fi

echo "✓ Pre-push checks passed"
