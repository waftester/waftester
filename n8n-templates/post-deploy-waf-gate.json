{
  "name": "Gate deployments on WAF security scan results with WAFtester",
  "description": "## What it does\n\nA CI/CD quality gate that blocks deployments when WAF protection is insufficient. Your pipeline sends a webhook with the target URL, the workflow runs [WAFtester](https://waftester.com) scans, and returns a pass/fail HTTP response the pipeline can gate on.\n\n## About WAFtester\n\n[WAFtester](https://waftester.com) is an open-source CLI for testing Web Application Firewalls. It ships 27 MCP tools, 2,800+ attack payloads across 18 categories (SQLi, XSS, SSRF, SSTI, command injection, XXE, and more), detection signatures for 26 WAF vendors and 9 CDNs, and enterprise-grade assessment with F1/MCC scoring and letter grades (A+ through F).\n\n- GitHub: [github.com/waftester/waftester](https://github.com/waftester/waftester)\n- Docs: [Installation](https://github.com/waftester/waftester/blob/main/docs/INSTALLATION.md) | [Examples](https://github.com/waftester/waftester/blob/main/docs/EXAMPLES.md) | [Commands](https://github.com/waftester/waftester/blob/main/docs/COMMANDS.md)\n\n## Who it's for\n\n- **DevOps teams** enforcing security gates in CI/CD\n- **Platform engineers** automating deployment approvals\n- **Security teams** requiring pre-deploy WAF validation\n\n## How it works\n\nThe workflow has seven nodes:\n\n1. **Webhook** \u2014 Receives a POST with `{\"target\": \"https://staging.example.com\", \"categories\": [\"sqli\", \"xss\"]}`\n2. **Detect WAF** \u2014 Calls WAFtester's `detect_waf` tool to fingerprint the WAF vendor\n3. **Start Scan** \u2014 Launches an async `scan` task with the requested attack categories\n4. **Wait** \u2014 Pauses to let the scan run\n5. **Poll Results** \u2014 Calls `get_task_status` to retrieve completed results\n6. **Evaluate** \u2014 Compares the detection rate against `WAF_PASS_THRESHOLD`\n7. **Respond** \u2014 Returns HTTP 200 (pass, deploy allowed) or HTTP 422 (fail, deploy blocked) with bypass details\n\n### CI/CD integration example\n\n```bash\n# In your pipeline\nRESPONSE=$(curl -s -w \"%{http_code}\" -o body.json \\\n  -X POST https://your-n8n/webhook/waf-gate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"target\": \"https://staging.example.com\", \"categories\": [\"sqli\", \"xss\"]}')\nif [ \"$RESPONSE\" != \"200\" ]; then echo \"WAF gate failed\"; exit 1; fi\n```\n\n## How to set up\n\n1. **Start WAFtester MCP server:**\n   `docker run -p 8080:8080 ghcr.io/waftester/waftester:latest mcp --http :8080`\n2. **Set environment variables:** `WAFTESTER_MCP_URL` and `WAF_PASS_THRESHOLD` (default: 90)\n3. **Copy the webhook URL** from the Webhook node into your CI/CD pipeline\n4. **Activate** the workflow\n\nAlternatively, use the included `docker-compose.yml` to run both n8n and WAFtester together.\n\n## Requirements\n\n| Requirement | Details |\n|---|---|\n| WAFtester MCP server | Docker image (`ghcr.io/waftester/waftester:latest`) or [binary install](https://github.com/waftester/waftester/blob/main/docs/INSTALLATION.md) |\n| CI/CD pipeline | Any pipeline that can call webhooks and read HTTP status codes (GitHub Actions, GitLab CI, Jenkins, etc.) |\n| Authorization | Only test targets you have explicit written permission to test |\n\n## Links\n\n- [WAFtester website](https://waftester.com)\n- [GitHub repository](https://github.com/waftester/waftester)\n- [Installation guide](https://github.com/waftester/waftester/blob/main/docs/INSTALLATION.md)\n- [Full examples](https://github.com/waftester/waftester/blob/main/docs/EXAMPLES.md)\n- [Docker Hub](https://hub.docker.com/r/waftester/waftester)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "waf-security-gate",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "793762f9-088e-4c68-b43e-9828be0fc25c",
      "name": "Deploy Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [672, 32],
      "webhookId": "0df18a16-adf4-415a-b073-426cb8b90fb4",
      "notes": "Receives POST from CI/CD pipeline. Body: {\"target\": \"https://...\", \"categories\": [\"sqli\", \"xss\"]}"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.WAFTESTER_MCP_URL || 'http://waftester:8080/mcp' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"detect_waf\",\n    \"arguments\": {\n      \"target\": \"{{ $('Deploy Webhook').item.json.body.target }}\"\n    }\n  }\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "123e328c-f1f2-4816-a1e8-cc87719f71ae",
      "name": "Detect WAF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [864, 32],
      "notes": "Identifies the WAF vendor protecting the target."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.WAFTESTER_MCP_URL || 'http://waftester:8080/mcp' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"scan\",\n    \"arguments\": {\n      \"target\": \"{{ $('Deploy Webhook').item.json.body.target }}\",\n      \"categories\": {{ $('Deploy Webhook').item.json.body.categories ? JSON.stringify($('Deploy Webhook').item.json.body.categories) : '[\"sqli\", \"xss\"]' }}\n    }\n  }\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "a1348c2f-b92c-4344-ad49-ed4841760fc8",
      "name": "Start Scan",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1072, 32],
      "notes": "Starts an async scan. Returns a task_id for polling."
    },
    {
      "parameters": {
        "amount": 30,
        "unit": "seconds"
      },
      "id": "a45cc213-a308-436f-b5a2-9592021f6c16",
      "name": "Wait for Scan",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [1264, 32],
      "notes": "Waits 30 seconds for the scan to complete before polling."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.WAFTESTER_MCP_URL || 'http://waftester:8080/mcp' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"get_task_status\",\n    \"arguments\": {\n      \"task_id\": \"{{ $('Start Scan').item.json.result.content[0].text.match(/task_id[\\\":\\\\s]+(task-[a-f0-9-]+)/)?.[1] || $('Start Scan').item.json.result.content[0].text }}\"\n    }\n  }\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "d595a7db-5a95-4cef-a502-0ba35bbdf01f",
      "name": "Poll Task Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1472, 32],
      "notes": "Polls get_task_status for scan results. The regex extracts the task_id from the scan response."
    },
    {
      "parameters": {
        "jsCode": "// Parse the MCP JSON-RPC response and calculate pass/fail\nconst response = $input.first().json;\nconst resultText = response.result?.content?.[0]?.text || '{}';\n\nlet parsed;\ntry {\n  parsed = JSON.parse(resultText);\n} catch (e) {\n  parsed = { error: resultText };\n}\n\nconst detectionRate = parsed.detection_rate || parsed.detectionRate || 0;\nconst threshold = Number($env.WAF_PASS_THRESHOLD) || 90;\nconst passed = detectionRate >= threshold;\n\nreturn [{\n  json: {\n    passed,\n    detection_rate: detectionRate,\n    threshold,\n    total_tests: parsed.total_tests || parsed.totalTests || 0,\n    blocked: parsed.blocked || 0,\n    bypasses: parsed.bypasses || parsed.bypass_count || 0,\n    waf_vendor: parsed.waf_vendor || parsed.wafVendor || 'unknown',\n    details: parsed\n  }\n}];"
      },
      "id": "78af2954-d79f-43cc-b17e-9b67375fc3c7",
      "name": "Parse Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1664, 32],
      "notes": "Extracts detection rate, bypass count, and compares against the WAF_PASS_THRESHOLD."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "d8246093-052a-4395-9b7b-7a23d3a36abb",
              "leftValue": "={{ $json.passed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "7b655595-dc14-4e30-b5f1-13c1b314e6ab",
      "name": "Pass or Fail?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1872, 32],
      "notes": "Routes to pass (HTTP 200) or fail (HTTP 422) response based on detection rate vs threshold."
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"status\": \"pass\",\n  \"detection_rate\": {{ $json.detection_rate }},\n  \"threshold\": {{ $json.threshold }},\n  \"total_tests\": {{ $json.total_tests }},\n  \"blocked\": {{ $json.blocked }},\n  \"waf_vendor\": \"{{ $json.waf_vendor }}\"\n}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "6dce4ceb-108e-47a5-b87c-c5bf9d140835",
      "name": "Respond Pass",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2064, -64],
      "notes": "Returns HTTP 200 — deployment can proceed."
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"status\": \"fail\",\n  \"detection_rate\": {{ $json.detection_rate }},\n  \"threshold\": {{ $json.threshold }},\n  \"total_tests\": {{ $json.total_tests }},\n  \"blocked\": {{ $json.blocked }},\n  \"bypasses\": {{ $json.bypasses }},\n  \"waf_vendor\": \"{{ $json.waf_vendor }}\"\n}",
        "options": {
          "responseCode": 422
        }
      },
      "id": "55ffe1fa-8a43-4aed-9f99-676333e1778c",
      "name": "Respond Fail",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2064, 128],
      "notes": "Returns HTTP 422 — deployment should be blocked. Includes bypass details."
    },
    {
      "parameters": {
        "content": "### How it works\n\n1. CI/CD pipeline POSTs target URL and categories to the webhook\n2. Detects WAF vendor, then runs security scan\n3. Polls for results and evaluates detection rate vs threshold\n4. Returns HTTP 200 (pass) or 422 (fail) so pipeline can gate\n\n### Setup steps\n\n1. Start WAFtester MCP server via Docker\n2. Set `WAFTESTER_MCP_URL` and `WAF_PASS_THRESHOLD` env vars\n3. Copy webhook URL into your CI/CD pipeline config\n4. Send POST with `{\"target\": \"...\", \"categories\": [...]}`",
        "width": 700,
        "height": 440
      },
      "id": "d7f85de9-f0b3-4b38-8eab-ee80d5ad1181",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-96, -240],
      "notes": ""
    },
    {
      "parameters": {
        "content": "## WAF Detection & Scan\n\nDetects WAF vendor and runs async security scan with 30s polling delay.",
        "width": 980,
        "height": 144
      },
      "id": "3323c452-47a0-4e78-837a-07a6c84912e1",
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [640, -240],
      "notes": ""
    },
    {
      "parameters": {
        "content": "## Gate Decision\n\nThe Code node calculates detection rate. If it meets the threshold, the pipeline proceeds. Otherwise, deployment is blocked with bypass details in the response body.",
        "width": 600,
        "height": 144
      },
      "id": "7e1c0ca5-48d1-4882-b8f1-811c849f0b60",
      "name": "Sticky Note2",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1648, -240],
      "notes": ""
    }
  ],
  "connections": {
    "Deploy Webhook": {
      "main": [
        [
          {
            "node": "Detect WAF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect WAF": {
      "main": [
        [
          {
            "node": "Start Scan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start Scan": {
      "main": [
        [
          {
            "node": "Wait for Scan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Scan": {
      "main": [
        [
          {
            "node": "Poll Task Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Poll Task Status": {
      "main": [
        [
          {
            "node": "Parse Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Results": {
      "main": [
        [
          {
            "node": "Pass or Fail?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass or Fail?": {
      "main": [
        [
          {
            "node": "Respond Pass",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Fail",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "active": false,
  "tags": [],
  "meta": {
    "templateCredsSetupCompleted": true
  }
}
